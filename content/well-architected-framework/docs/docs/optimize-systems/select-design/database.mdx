---
page_title: Design your databases
description: Learn how to design, load test, stress test, and scale your databases.
---

# Design your databases

Your databases are one of the most critical components of your infrastructure but can also be the hardest to scale. Unlike stateless infrastructure like your compute instances, performance issues in a database can be difficult to diagnose and fix. Proactive capacity planning helps you identify how your services use your databases, how that changes as the load increases, and can help you develop a plan on how to scale your database infrastructure before it causes issues for your applications.

## Plan for your known capacity

Planning your database's capacity needs is a complex question of both storage and performance. Understanding how your applications and services use your databases is critical to properly build and scale your databases. 

As you design the infrastructure for your database, you should ask yourself questions like the following:

- How much data do you expect the database to hold?
- How do your storage needs grow over time?
- How do your services interact with the database? Do they mostly send reads, writes, or a mix of both?
- What do queries to your database look like? Are they complex and require lots of resources to process, or are they simple and quick to process?
- How quick must the database respond to queries?
- How strict are your consistency requirements? Do your data need strong consistency or can it be eventually consistent?

Before users start sending traffic to your services, it can be useful to test your database as you monitor how it responds to better learn your bottlenecks and plan for how to best scale your database. The following are two types of tests that you can run to help plan your database capacity requirements:

- **Load tests:** Test your database under normal workloads. You can monitor metrics like response time and transactions per second to identify slow queries, indexing issues, and connection pool limitations.
- **Stress tests:** Test your database under extremely high, unnatural workloads. These tests are useful to see how it handles sudden traffic spikes, large operations, or complex queries. These tests help identify how your infrastructure may break under extreme conditions.

## Design to meet demand

Your early design decisions to architect your databases have a big effect on how you manage, run, and scale them as the load on them increases. By understanding what the workload on your databases look like, you can plan how to best optimize your infrastructure and database configuration. Some examples of these design decisions include the following:

- **Indexing:** Database indexing improves query performance by trading disk storage and write speeds for faster read speeds. Create indexes for frequently read data, but make sure to test how this affects your write speed.
- **Read replicas:** Read replicas are read-only copies of your database, and are useful for reducing the load on your database if your services make many read requests. 
- **Caching:** Caching reduces database load by storing frequently accessed data in memory. This is particularly effective for data that changes infrequently.
- **Connection pooling:** Connection pools maintain a set of reusable connections, reducing overhead and improving performance.
- **Partitioning and sharding:** Partitioning and sharding divide large datasets into smaller, easier to manage datasets. For very large datasets, partitioning divides data within a single database, while sharding distributes data across multiple databases.

Some cloud providers let you create database read replicas using the same resource that you used to create the original database. For example, the following Terraform creates a read-write database named `rw-database`, then creates a separate read replica named `ro-database`:

```hcl

resource "aws_db_instance" "primary" {
  identifier        = "rw-database"
  engine            = "postgres"
  engine_version    = "18.1"
  instance_class    = "db.t3.micro"
  allocated_storage = 20
  storage_type      = "gp3"

  username = "postgres"
  password = random_password.db_password.result

  backup_retention_period = 7
  skip_final_snapshot = true
}

resource "aws_db_instance" "replica" {
  identifier          = "ro-database"
  replicate_source_db = aws_db_instance.primary.identifier
  instance_class      = "db.t3.micro"

  skip_final_snapshot = true

  tags = {
    Name = "Read Replica"
  }
}
```


## Respond to scale issues
Just as you monitor and scale your compute infrastructure, you should have similar insights into your database. With proper monitoring, alerting, and identifying key performance metrics, you can address approaching performance issues before they have a negative impact on your applications and services. 

- **Monitoring and alerting:** Monitoring key metrics of your database, such as storage space, query latency, and connection count, lets you understand when you are approaching the bottlenecks you identified during load and stress testing. With early alerts, you can respond to potential issues before they affect your applications and services.
- **Query optimization:** While adding more resources to your database, such as disk or additional nodes, can help address performance issues, they can also sometimes hide more fundamental issues. Investigate slow queries to identify potential improvements you can make so that your database can make better use of your existing infrastructure instead of increasing cost.
- **Capacity scaling:** As the number of services, users, and queries to your database grows, your database's capacity will eventually need to grow with it. Use your monitoring and alerts to know when you are approaching different limits in your database before you exceed capacity. Different databases offer different ways to scale a cluster, so refer to your database documentation to learn more about your options.

HashiCorp resources:

- Read the [Define your database infrastructure](/well-architected-framework/define-and-automate-processes/define/as-code/database) Well-Architected Framework documentation.
- Learn how to [Manage AWS RDS instances](/terraform/tutorials/aws/aws-rds) and how to [Upgrade AWS RDS major versions](/terraform/tutorials/aws/rds-upgrade) with Terraform.
## Next steps

In this section of Select and design infrastructure, you learned how to profile the workload on your database with load and stress tests, react to growing database needs, and design to maximize your database performance as your needs change. Select and design infrastructure is part of the [Optimize systems pillar](/well-architected-framework/optimize-systems).

To learn more about how to design and scale your infrastructure, refer to the following resources:

- [Select and scale compute instances](/well-architected-framework/optimize-systems/select-design/network)
- [Design your network](/well-architected-framework/optimize-systems/select-design/network)