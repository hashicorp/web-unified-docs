---
page_title: Manage artifact repositories as code
description: Manage Artifactory and Nexus repositories as code to standardize dependency management, enforce security policies, ensure consistent access control, and automate repository configuration.
---

# Manage artifact repositories as code

Manually configuring artifact repositories can create inconsistent settings across environments, security gaps in access control, and configuration drift. Managing artifact repositories as code with Terraform enables you to standardize repository configuration, enforce access policies, automate proxy setup for package managers, and ensure consistent artifact management across your organization.

Artifact repositories like JFrog Artifactory, Sonatype Nexus, and Azure Artifacts serve as central hubs for build artifacts and dependency packages. While teams use these repositories to store and retrieve packages, the repositories themselves require configuration. Terraform can manage artifact repository configuration across different platforms, ensuring consistent setup and enabling infrastructure as code practices for your build infrastructure.

## Why manage artifact repositories as code

Managing artifact repository configuration as code addresses the following operational and security challenges:

- **Reduce configuration drift:** Managing repositories as code promotes identical configuration across your environments, with variations defined in code rather than through manual changes.

- **Enforce security policies:** Terraform enforces consistent access control, scanning policies, and artifact retention rules across all repositories from a single configuration.

- **Reduce repository management:** Terraform automates repository creation and configuration, enabling you to provision dozens of repositories with standardized settings.

- **Enable audit and compliance tracking:** Terraform stores configuration in version control to create comprehensive audit trails with commit history and approval workflows.

## Choose an artifact repository

Select an artifact repository based on your infrastructure and requirements:

**Use JFrog Artifactory when:**
- You need a universal repository supporting multiple package types (Docker, npm, Maven, Go, Python, NuGet)
- You require advanced features like JFrog Xray vulnerability scanning
- You operate in multi-cloud or hybrid environments

**Use Sonatype Nexus when:**
- You need open-source artifact management with enterprise support options
- You require extensive cleanup policies and blob store management
- You prefer self-hosted solutions with flexible deployment options

**Use Azure Artifacts when:**
- Your organization uses Azure DevOps for CI/CD pipelines
- You need tight integration with Azure services and authentication
- Your teams primarily work within the Microsoft ecosystem

**Use AWS CodeArtifact when:**
- Your infrastructure runs primarily on AWS
- You need native IAM integration for access control
- You require integration with AWS services like Lambda and ECS

## JFrog Artifactory

The JFrog Artifactory provider lets you manage Artifactory configuration through Terraform instead of the Artifactory web interface. Artifactory is a universal artifact repository that caches external dependencies and stores internal packages. The Terraform provider automates Artifactory setup, ensuring consistent configuration across your development, staging, and production environments.

The following example creates a PyPI repository for Python packages:

<CodeBlockConfig filename="artifactory.tf">

```hcl
# Required for Terraform 1.0 and up (https://www.terraform.io/upgrade-guides)
terraform {
  required_providers {
    artifactory = {
      source  = "jfrog/artifactory"
      version = "12.3.3"
    }
  }
}

# Configure the Artifactory provider
provider "artifactory" {
  url           = "${var.artifactory_url}/artifactory"
  access_token  = var.artifactory_access_token
}

# Create a new repository
resource "artifactory_local_pypi_repository" "pypi-libs" {
  key             = "pypi-libs"
  repo_layout_ref = "simple-default"
  description     = "A pypi repository for python packages"
}
```

</CodeBlockConfig>

The configuration creates a PyPI repository that teams can use to publish and retrieve Python packages.

Use the Artifactory provider for the following use cases:

- Create repositories for multiple package types such as Docker, npm, Maven, Go, and Python
- Configure virtual repositories that combine local and remote sources
- Set up remote proxy repositories to cache external dependencies
- Integrate with JFrog Xray for vulnerability scanning

Refer to the [Artifactory provider documentation](https://registry.terraform.io/providers/jfrog/artifactory/latest/docs) for configuration examples and resource references.

## Sonatype Nexus Repository

The Nexus provider lets you manage Nexus Repository Manager configuration through Terraform instead of the Nexus web interface. Nexus Repository Manager serves as a central repository for build artifacts and dependencies across multiple package formats. The Terraform provider automates Nexus configuration, ensuring consistent repository setup and policy enforcement across your infrastructure.

Use the Nexus provider for the following use cases:

- Manage Maven, npm, Docker, and other repository types
- Configure cleanup policies to remove old artifacts automatically
- Set up blob stores for artifact storage organization
- Create group repositories that aggregate multiple sources
- Configure content selectors for fine-grained access control

Refer to the [Nexus provider documentation](https://registry.terraform.io/providers/datadrivers/nexus/latest/docs) for configuration examples and resource references.

## Azure Artifacts

The Azure DevOps provider lets you manage Azure Artifacts configuration through Terraform instead of the Azure DevOps web interface. Azure Artifacts provides package management integrated with Azure DevOps services and pipelines. The Terraform provider automates feed creation and configuration, ensuring consistent artifact management across your Azure DevOps organization.

The following example creates an Azure DevOps artifact feed:

<CodeBlockConfig filename="azure-devops-feed.tf">

```hcl
terraform {
  required_providers {
    azuredevops = {
      source  = "microsoft/azuredevops"
      version = "~> 1.0"
    }
  }
}

# Configure the Azure DevOps provider
provider "azuredevops" {
  org_service_url = "https://dev.azure.com/your-organization"
}

# Create an artifact feed
resource "azuredevops_feed" "packages" {
  name = "application-packages"
}

# Configure feed permissions
resource "azuredevops_feed_permission" "team" {
  feed_id             = azuredevops_feed.packages.id
  role                = "contributor"
  identity_descriptor = "your-team-descriptor"
}
```

</CodeBlockConfig>

The configuration creates an Azure DevOps artifact feed for package management and assigns team permissions for publishing and retrieving packages.

Use the Azure DevOps provider for the following use cases:

- Create artifact feeds for teams using Azure DevOps
- Configure upstream sources to proxy public registries
- Manage feed permissions and access control
- Integrate with Azure DevOps pipelines

Refer to the [Azure DevOps provider documentation](https://registry.terraform.io/providers/microsoft/azuredevops/latest/docs) for configuration examples and feed resource references.

## AWS CodeArtifact

The AWS provider lets you manage AWS CodeArtifact configuration through Terraform instead of the AWS Console. CodeArtifact provides secure and scalable artifact management integrated with AWS services and IAM. The Terraform provider automates repository and domain creation, ensuring consistent artifact management across your AWS accounts.

The following example creates a CodeArtifact domain and repository:

<CodeBlockConfig filename="codeartifact.tf">

```hcl
resource "aws_kms_key" "example" {
  description = "domain key"
}

resource "aws_codeartifact_domain" "example" {
  domain         = "example"
  encryption_key = aws_kms_key.example.arn
}

resource "aws_codeartifact_repository" "test" {
  repository = "example"
  domain     = aws_codeartifact_domain.example.domain
}
```

</CodeBlockConfig>

The configuration creates a KMS-encrypted CodeArtifact domain and repository for managing application dependencies.

Use the AWS provider for the following use cases:

- Create artifact repositories in AWS for serverless and containerized applications
- Configure upstream connections to public package registries
- Manage repository permissions using IAM policies
- Integrate with AWS services like Lambda and ECS

Refer to the [AWS CodeArtifact documentation](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/codeartifact_repository) for configuration examples and resource references.

## Secure artifact repository credentials with Vault

After defining artifact repositories as code, secure the credentials used to authenticate to these repositories. Store artifact repository credentials in Vault to centralize secret management, enable automatic credential rotation, and maintain comprehensive audit logs. Vault issues dynamic, short-lived credentials to CI/CD pipelines and build systems, significantly reducing the risk of credential compromise.

The following example shows how Terraform retrieves Artifactory credentials from Vault:

<CodeBlockConfig filename="vault-artifactory.tf">

```hcl
terraform {
  required_providers {
    vault = {
      source  = "hashicorp/vault"
      version = "~> 4.0"
    }
    artifactory = {
      source  = "jfrog/artifactory"
      version = "~> 12.3"
    }
  }
}

# Retrieve Artifactory credentials from Vault
data "vault_kv_secret_v2" "artifactory" {
  mount = "secret"
  name  = "artifactory/admin"
}

# Configure Artifactory provider with Vault-sourced credentials
provider "artifactory" {
  url          = "https://artifactory.example.com/artifactory"
  access_token = data.vault_kv_secret_v2.artifactory.data["access_token"]
}

# Create repository with credentials from Vault
resource "artifactory_local_pypi_repository" "pypi-libs" {
  key             = "pypi-libs"
  repo_layout_ref = "simple-default"
  description     = "A pypi repository for python packages"
}
```

</CodeBlockConfig>

The configuration retrieves Artifactory credentials from Vault's secret store, eliminating hardcoded credentials in Terraform configurations. Before using this pattern, store your artifact repository credentials in Vault using the Vault CLI (`vault kv put secret/artifactory/admin access_token=your-token`) or API. Vault's audit logs track all credential access, providing visibility into artifact repository authentication. When you rotate credentials in Vault, CI/CD pipelines and Terraform automatically use the updated credentials without configuration changes.

## Enforce artifact repository policies with Sentinel

Use Sentinel policies to enforce artifact repository configuration standards across your organization. Sentinel validates Terraform plans before execution, ensuring all artifact repositories meet security and compliance requirements.

The following Sentinel policy enforces artifact repository security standards:

<CodeBlockConfig filename="artifactory-policy.sentinel">

```sentinel
import "tfplan/v2" as tfplan

# Require all Artifactory repositories to have descriptions
require_descriptions = rule {
  all tfplan.resource_changes as _, rc {
    rc.type contains "artifactory_local" and
    length(rc.change.after.description else "") > 0
  }
}

# Require all repositories to be private (not anonymous access)
require_private_repos = rule {
  all tfplan.resource_changes as _, rc {
    rc.type contains "artifactory_local" and
    (rc.change.after.repo_layout_ref else "simple-default") != ""
  }
}

# Main rule
main = rule {
  require_descriptions and
  require_private_repos
}
```

</CodeBlockConfig>

The Sentinel policy validates that all Artifactory repositories include descriptions for documentation and use proper repository layouts. Terraform plans that create non-compliant repositories fail the policy check, preventing misconfigured artifact repositories from reaching production.

## Integrate artifact repositories with CI/CD

After configuring artifact repositories as code, integrate them with your CI/CD pipelines to automate artifact publishing and retrieval. Your CI/CD workflows authenticate to your artifact repository using credentials retrieved from Vault and publish build artifacts or pull dependencies for application builds. Refer to [Implement CI/CD](/well-architected-framework/define-and-automate-processes/automate/cicd) for guidance on integrating artifact repositories with your deployment pipelines.

## HashiCorp resources

- [Centralize packages and dependencies](/well-architected-framework/define-and-automate-processes/define/centralize-packages)
- [Define infrastructure as code](/well-architected-framework/define-and-automate-processes/define/as-code/infrastructure)
- [Use version control](/well-architected-framework/define-and-automate-processes/define/version-control)

Learn Terraform for artifact management:

- Get started with [Terraform tutorials](/terraform/tutorials) and read the [Terraform documentation](/terraform/docs) for infrastructure as code
- Browse [Terraform providers](/terraform/docs/providers) for artifact repository integrations
- Review the [Terraform Registry documentation](/terraform/registry) for provider versioning and module usage

Artifact management Terraform providers:

- Read the [Artifactory provider documentation](https://registry.terraform.io/providers/jfrog/artifactory/latest/docs)
- Read the [Nexus provider documentation](https://registry.terraform.io/providers/datadrivers/nexus/latest/docs)
- Read the [AWS CodeArtifact documentation](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/codeartifact_repository)
- Read the [Azure Artifacts documentation](https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/devops_feed)

Secure credentials with Vault:

- Get started with [Vault tutorials](/vault/tutorials) and read the [Vault documentation](/vault/docs)
- Learn about [Vault secrets engines](/vault/docs/secrets) for managing artifact repository credentials
- Read the [Vault Terraform provider documentation](https://registry.terraform.io/providers/hashicorp/vault/latest/docs) for integration examples
- Explore [dynamic secrets](/vault/docs/secrets/databases) for automated credential rotation

Enforce policies with Sentinel:

- Learn about [Sentinel policy as code](/terraform/cloud-docs/policy-enforcement/sentinel) for governance
- Read the [Sentinel language documentation](/sentinel/docs/language) for policy syntax
- Explore [Sentinel policy examples](https://github.com/hashicorp/terraform-sentinel-policies) for common patterns
- Learn to [test Sentinel policies](/terraform/cloud-docs/policy-enforcement/sentinel/testing) before deployment

## Next steps

In this section of [Codify infrastructure and tools](/well-architected-framework/define-and-automate-processes/define/as-code), you learned how to manage artifact repository configuration as code to standardize dependency management, enforce security policies, and ensure consistent package access. You explored how Terraform configures Artifactory and Nexus repositories with access control, proxying, and retention policies. Manage artifact repositories as code is part of the [Define and automate processes pillar](/well-architected-framework/define-and-automate-processes).

Visit the following documents to continue building your automation strategy:

- [Implement CI/CD](/well-architected-framework/define-and-automate-processes/automate/cicd) to automate artifact publishing and deployment
- [Create reusable modules](/well-architected-framework/define-and-automate-processes/define/modules) to standardize artifact repository configurations
- [Implement testing](/well-architected-framework/define-and-automate-processes/automate/testing) to validate artifact repository configurations
