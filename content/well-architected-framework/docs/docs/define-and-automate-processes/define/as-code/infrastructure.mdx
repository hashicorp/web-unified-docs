---
page_title: Define your infrastructure systems
description: Define your critical infrastructure systems and tools using infrastructure as code to establish a foundation for automation.
---

# Define your infrastructure systems

Before you can automate your infrastructure processes, you need to clearly define what infrastructure systems and tools you need. Using infrastructure as code (IaC) to define your systems creates a clear, version-controlled specification of your infrastructure that can be reviewed, tested, and automated.

## Why define infrastructure as code

Defining infrastructure as code addresses the following operational challenges:

- **Eliminate manual configuration errors:** Manual infrastructure provisioning through cloud consoles leads to inconsistent configurations, missed steps, and deployment failures. Infrastructure as code defines infrastructure declaratively, ensuring every deployment matches your specifications exactly and eliminating human error from the provisioning process.

- **Enable team collaboration:** Traditional infrastructure management creates knowledge silos where only specific team members understand production systems. Infrastructure as code stores configurations in version control, enabling code review, collaboration, and knowledge sharing across your entire team through pull requests and documentation.

- **Provide auditability and compliance:** Manual changes through cloud consoles leave incomplete audit trails that fail compliance requirements. Infrastructure as code captures every infrastructure modification in version control with commit messages explaining who made changes, when, and why, creating comprehensive audit trails for security and compliance teams.

- **Accelerate deployment velocity:** Manually provisioning infrastructure for each environment takes hours or days and blocks application deployments. Infrastructure as code deploys identical infrastructure across development, staging, and production in minutes, accelerating feature delivery and enabling rapid experimentation.

## Benefits of infrastructure as code

Defining your infrastructure as code provides the following benefits:

- **Version control:** Track every infrastructure change over time through Git history, enabling you to understand how your infrastructure evolved and why specific decisions were made.

- **Consistency:** Deploy identical infrastructure across all environments, eliminating configuration drift between development, staging, and production that causes environment-specific bugs.

- **Testing:** Validate infrastructure changes before deployment through automated testing, catching errors and policy violations before they reach production systems.

- **Automation:** Integrate infrastructure deployments into CI/CD pipelines, enabling continuous delivery of infrastructure changes alongside application deployments.

- **Documentation as code:** Infrastructure definitions serve as living documentation that stays synchronized with actual deployed resources, unlike separate documentation that quickly becomes outdated.

- **Disaster recovery:** Recreate entire infrastructure environments from code within minutes after catastrophic failures, significantly reducing recovery time objectives.

## Define infrastructure as code

Infrastructure as code lets you define your infrastructure using declarative configuration files, making it easier to understand your resource configurations and infrastructure topology. When you define your infrastructure as code, you can use the same engineering practices for your infrastructure as for application development, such as code review, automated deployment, and phased rollout.

## Use Terraform to define your infrastructure

Terraform uses providers to interact with cloud resources and services. Terraform creates and manages these resources by storing the state of your infrastructure. You define the desired state of your infrastructure using HashiCorp Configuration Language (HCL), and Terraform deploys and configures the resources to match your configuration.

<VideoEmbed url="https://www.youtube.com/embed/ZFLWA1kQ3ls"/>

### Example: Define basic infrastructure

The following Terraform configuration defines basic infrastructure including networking, compute, and storage resources:

```hcl
# main.tf - Basic infrastructure configuration
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = "us-west-2"
}

# Define virtual network
resource "aws_vpc" "main" {
  cidr_block           = "10.0.0.0/16"
  enable_dns_hostnames = true

  tags = {
    Name        = "main-vpc"
    Environment = "production"
  }
}

# Define subnet within the network
resource "aws_subnet" "public" {
  vpc_id                  = aws_vpc.main.id
  cidr_block              = "10.0.1.0/24"
  map_public_ip_on_launch = true

  tags = {
    Name = "public-subnet"
  }
}

# Define compute instance
resource "aws_instance" "web" {
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = "t3.micro"
  subnet_id     = aws_subnet.public.id

  tags = {
    Name = "web-server"
    Role = "webserver"
  }
}

# Define storage
resource "aws_s3_bucket" "app_data" {
  bucket = "my-app-data-bucket"

  tags = {
    Name        = "Application Data"
    Environment = "production"
  }
}

# Output important values
output "instance_public_ip" {
  value       = aws_instance.web.public_ip
  description = "Public IP address of the web server"
}

output "bucket_name" {
  value       = aws_s3_bucket.app_data.id
  description = "Name of the S3 bucket"
}
```

This configuration defines a VPC with a subnet, launches an EC2 instance in that subnet, and creates an S3 bucket for application data. When you run `terraform apply`, Terraform creates these resources in AWS. The configuration shows resource dependenciesâ€”the subnet references the VPC ID, and the instance references the subnet ID. Terraform automatically determines the correct creation order based on these dependencies.

### Example: Define multi-tier application infrastructure

The following Terraform configuration defines a complete multi-tier web application with load balancing, auto-scaling, and a database:

```hcl
# Multi-tier application infrastructure
variable "environment" {
  description = "Environment name"
  default     = "production"
}

# Application Load Balancer
resource "aws_lb" "app" {
  name               = "${var.environment}-app-lb"
  load_balancer_type = "application"
  subnets            = [aws_subnet.public_a.id, aws_subnet.public_b.id]
  security_groups    = [aws_security_group.lb.id]

  tags = {
    Environment = var.environment
  }
}

# Target group for web tier
resource "aws_lb_target_group" "web" {
  name     = "${var.environment}-web-tg"
  port     = 80
  protocol = "HTTP"
  vpc_id   = aws_vpc.main.id

  health_check {
    path                = "/health"
    healthy_threshold   = 2
    unhealthy_threshold = 10
  }
}

# Auto Scaling Group for web tier
resource "aws_autoscaling_group" "web" {
  name                = "${var.environment}-web-asg"
  vpc_zone_identifier = [aws_subnet.private_a.id, aws_subnet.private_b.id]
  target_group_arns   = [aws_lb_target_group.web.arn]
  health_check_type   = "ELB"

  min_size         = 2
  max_size         = 10
  desired_capacity = 3

  launch_template {
    id      = aws_launch_template.web.id
    version = "$Latest"
  }
}

# Launch template for web servers
resource "aws_launch_template" "web" {
  name_prefix   = "${var.environment}-web-"
  image_id      = data.aws_ami.web_app.id
  instance_type = "t3.small"

  vpc_security_group_ids = [aws_security_group.web.id]

  tag_specifications {
    resource_type = "instance"
    tags = {
      Name        = "${var.environment}-web-server"
      Tier        = "web"
      Environment = var.environment
    }
  }
}

# RDS Database for application tier
resource "aws_db_instance" "app_db" {
  identifier           = "${var.environment}-app-db"
  engine               = "postgres"
  engine_version       = "15.3"
  instance_class       = "db.t3.medium"
  allocated_storage    = 100
  storage_encrypted    = true

  db_name  = "appdb"
  username = "dbadmin"
  password = data.vault_generic_secret.db.data["password"]

  vpc_security_group_ids = [aws_security_group.database.id]
  db_subnet_group_name   = aws_db_subnet_group.main.name

  backup_retention_period = 7
  skip_final_snapshot     = false
  final_snapshot_identifier = "${var.environment}-app-db-final-snapshot"

  tags = {
    Environment = var.environment
    Tier        = "database"
  }
}

# Output connection information
output "load_balancer_dns" {
  value       = aws_lb.app.dns_name
  description = "DNS name of the application load balancer"
}

output "database_endpoint" {
  value       = aws_db_instance.app_db.endpoint
  description = "Connection endpoint for the database"
  sensitive   = true
}
```

This configuration defines a production-grade multi-tier application. The load balancer distributes traffic across an auto-scaling group of web servers running in private subnets. The auto-scaling group automatically adjusts capacity between 2 and 10 instances based on demand. The RDS database runs in isolated database subnets with encryption enabled and automated backups. The configuration uses variables for environment-specific values and retrieves the database password securely from Vault. Running `terraform apply` provisions this complete infrastructure stack with proper networking, security groups, and high availability.

### Terraform maturity progression

The following Terraform maturity model provides a roadmap to help you create consistent infrastructure, application configurations, and images:

1. **Adopt:** Compose infrastructure as code in Terraform files using HCL to provision resources from any infrastructure provider. Start by defining simple resources like virtual machines, networks, and storage to replace manual provisioning through cloud consoles.

1. **Build:** Establish infrastructure automation workflows to compose, collaborate, reuse, and provision infrastructure as code across IT operations and teams of developers. Implement version control, code review processes, and shared modules that multiple teams can consume.

1. **Standardize:** Establish guardrails for security, compliance, and cost management through role-based access controls, policy enforcement with Sentinel, and comprehensive audit logging. Create organizational standards for naming, tagging, and resource configurations.

1. **Scale:** Extend workflow automation to all teams in the organization with self-service infrastructure as code through platforms like HCP Waypoint. Integrate Terraform with version control systems, ITSM workflows, and CI/CD pipelines for fully automated infrastructure delivery.

### Infrastructure systems to define with Terraform

Use Terraform to define the following infrastructure systems:

- **CI/CD infrastructure:** Define CI/CD pipeline infrastructure including build servers, artifact repositories, and deployment automation systems that support your software delivery processes.

- **Container orchestration platforms:** Define Kubernetes clusters, Nomad clusters, and their supporting infrastructure including control planes, worker nodes, networking, and storage for container workloads.

- **Database systems:** Define database instances, storage volumes, backup configurations, and replication setups for both relational and NoSQL databases across multiple cloud providers.

- **Monitoring and observability systems:** Define monitoring agents, log aggregation infrastructure, metrics collection systems, and observability platforms that provide visibility into your infrastructure and applications.

- **Security systems:** Define identity providers, access control policies, security groups, network firewalls, and encryption key management systems that protect your infrastructure.

- **Version control systems:** Define Git repository infrastructure, access controls, webhook configurations, and integration settings that support your development workflows.

## Next steps

In this section of [Codify infrastructure and tools](/well-architected-framework/define-and-automate-processes/define/as-code), you learned how to define your infrastructure systems using infrastructure as code to establish a foundation for automation. Define your infrastructure systems is part of the [Define and automate processes pillar](/well-architected-framework/define-and-automate-processes).

Refer to the following documents to learn more about defining specific infrastructure components:

- [Create reusable infrastructure modules](/well-architected-framework/define-and-automate-processes/define/modules) to standardize your infrastructure deployments
- [Define CI/CD infrastructure](/well-architected-framework/define-and-automate-processes/define/as-code/cicd) to establish consistent CI/CD processes
- [Define container orchestration](/well-architected-framework/define-and-automate-processes/define/as-code/orchestration) to configure Kubernetes and Nomad platforms
- Topics in **Automate your workflows**
  - [CI/CD](/well-architected-framework/define-and-automate-processes/automate/cicd) - Implement automation for infrastructure and applications
  - [Testing](/well-architected-framework/define-and-automate-processes/automate/testing) - Implement testing for infrastructure and applications
  - [Deployment](/well-architected-framework/define-and-automate-processes/automate/deployments) - Implement deployment for infrastructure and applications
  - [Packaging](/well-architected-framework/define-and-automate-processes/automate/packaging) - Package applications for deployment

To learn more about Terraform and infrastructure as code, you can check out the following resources:

- [Terraform providers registry](https://registry.terraform.io/browse/providers) - Browse available Terraform providers
- [Terraform configuration tutorials](/terraform/tutorials/configuration-language) - Learn HCL by writing Terraform configuration
