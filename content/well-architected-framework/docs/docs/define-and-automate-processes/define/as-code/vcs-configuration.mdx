---
page_title: Manage VCS configuration as code
description: Manage version control system configuration as code using Terraform GitHub or GitLab providers to ensure consistent repository settings and enable automation.
---

# Manage VCS configuration as code

Manually configuring version control systems through web interfaces creates inconsistent repository settings, security gaps, and configuration drift across teams. Managing VCS configuration as code with Terraform enables you to standardize repository settings, enforce security policies, and automate team and permission management across your entire organization. This approach ensures consistent configuration, provides audit trails for compliance, and eliminates manual configuration errors that create security vulnerabilities.

Version control systems (VCS), such as GitHub, GitLab, and Bitbucket, store and version your infrastructure code, application code, and configuration files. While teams use VCS to manage their infrastructure as code, the VCS platforms themselves require configurationâ€”repository settings, branch protections, team permissions, and security controls. Terraform can manage both on-premises VCS installations and VCS platforms provided as a service.

## Why manage VCS configuration as code

Managing VCS configuration as code addresses the following operational and security challenges:

- **Eliminate security policy inconsistencies:** Manually configuring branch protection rules and access controls across hundreds of repositories creates gaps where critical repositories lack required approvals or allow force pushes to production branches. Terraform enforces consistent security policies across all repositories from a single configuration, preventing configuration drift that creates vulnerabilities.

- **Prevent configuration drift across repositories:** When teams create repositories through web interfaces, each repository receives different settings for merge strategies, default branches, and CI/CD integrations. Managing VCS configuration as code ensures identical baseline configurations for all repositories, with variations defined explicitly in code rather than accumulated through manual changes.

- **Reduce team and permission management overhead:** Manually adding users to teams, assigning repository permissions, and maintaining access across dozens of repositories consumes significant administrative time and creates errors. Terraform automates team membership and permission assignment, enabling you to manage access for your entire organization from code that can be reviewed and audited.

- **Enable audit and compliance requirements:** Compliance frameworks require audit trails showing who made infrastructure changes and when. Manual VCS configuration changes through web interfaces provide limited audit capabilities, while Terraform configurations stored in version control create comprehensive audit trails with commit history, pull request reviews, and approval workflows.

## Manage GitHub configuration

The following example shows Terraform managing GitHub repository configuration, including branch protection rules and team permissions:

<CodeBlockConfig filename="github.tf">

```hcl
terraform {
  required_providers {
    github = {
      source  = "integrations/github"
      version = "~> 6.0"
    }
  }
}

provider "github" {
  owner = "your-organization"
}

# Create repository with standard configuration
resource "github_repository" "infrastructure" {
  name        = "infrastructure-production"
  description = "Production infrastructure as code"
  visibility  = "private"
  auto_init   = true
}

# Enforce branch protection on main branch
resource "github_branch_protection" "main" {
  repository_id = github_repository.infrastructure.node_id
  pattern       = "main"

  # Require pull request reviews
  required_pull_request_reviews {
    required_approving_review_count = 2
  }

  # Prevent force pushes and deletions
  allows_force_pushes = false
  allows_deletions    = false
}

# Create team with repository access
resource "github_team" "platform" {
  name        = "platform-engineering"
  description = "Platform engineering team"
  privacy     = "closed"
}

# Assign team permissions to repository
resource "github_team_repository" "platform_infra" {
  team_id    = github_team.platform.id
  repository = github_repository.infrastructure.name
  permission = "maintain"
}
```

</CodeBlockConfig>

This configuration creates a repository with security best practices enabled, enforces branch protection requiring two approvals before merging, and assigns team permissions. When you apply this configuration, Terraform creates the repository with consistent settings that match your organizational standards.

## Manage GitLab configuration

The following example shows Terraform managing GitLab project configuration with merge request approvals and protected branches:

<CodeBlockConfig filename="gitlab.tf">

```hcl
terraform {
  required_providers {
    gitlab = {
      source  = "gitlabhq/gitlab"
      version = "~> 17.0"
    }
  }
}

provider "gitlab" {
  token = var.gitlab_token
}

# Create GitLab group for organization
resource "gitlab_group" "platform" {
  name             = "platform-engineering"
  path             = "platform"
  description      = "Platform engineering infrastructure"
  visibility_level = "private"
}

# Create project with standard settings
resource "gitlab_project" "infrastructure" {
  name             = "infrastructure-production"
  namespace_id     = gitlab_group.platform.id
  description      = "Production infrastructure as code"
  visibility_level = "private"

  # Require successful pipeline before merging
  only_allow_merge_if_pipeline_succeeds = true
}

# Protect main branch
resource "gitlab_branch_protection" "main" {
  project            = gitlab_project.infrastructure.id
  branch             = "main"
  push_access_level  = "no one"
  merge_access_level = "maintainer"
}

# Require approvals for merge requests
resource "gitlab_project_approval_rule" "security" {
  project            = gitlab_project.infrastructure.id
  name               = "Security review required"
  approvals_required = 2
  group_ids          = [gitlab_group.platform.id]
}
```

</CodeBlockConfig>

This configuration creates a GitLab project that requires pipeline success before merging, protects the main branch from direct pushes, and enforces approval requirements through code.

HashiCorp resources:

- Learn to [define infrastructure as code](/well-architected-framework/define-and-automate-processes/define/as-code/infrastructure) to manage VCS platforms consistently
- Store code in [version control](/well-architected-framework/define-and-automate-processes/define/version-control) for infrastructure and application code
- Learn to [manage GitHub users, teams, and repository permissions](/terraform/tutorials/it-saas/github-user-teams) with Terraform

GitHub provider documentation:

- Read the [GitHub provider documentation](https://registry.terraform.io/providers/integrations/github/latest/docs) for complete configuration options
- Explore [repository resources](https://registry.terraform.io/providers/integrations/github/latest/docs/resources/repository) to configure repository settings
- Configure [branch protection](https://registry.terraform.io/providers/integrations/github/latest/docs/resources/branch_protection) to enforce security policies
- Manage [teams](https://registry.terraform.io/providers/integrations/github/latest/docs/resources/team) and [team repository permissions](https://registry.terraform.io/providers/integrations/github/latest/docs/resources/team_repository)

GitLab provider documentation:

- Read the [GitLab provider documentation](https://registry.terraform.io/providers/gitlabhq/gitlab/latest/docs) for complete configuration options
- Configure [projects](https://registry.terraform.io/providers/gitlabhq/gitlab/latest/docs/resources/project) and [groups](https://registry.terraform.io/providers/gitlabhq/gitlab/latest/docs/resources/group)
- Set up [branch protection](https://registry.terraform.io/providers/gitlabhq/gitlab/latest/docs/resources/branch_protection) to secure branches
- Configure [approval rules](https://registry.terraform.io/providers/gitlabhq/gitlab/latest/docs/resources/project_approval_rule) for merge requests

Additional resources:

- Browse [version control systems](https://registry.terraform.io/browse/providers?category=version-control-systems) in the Terraform Registry
- Learn about [Terraform modules](/well-architected-framework/define-and-automate-processes/define/modules) to create reusable VCS configurations
- Explore [policy as code](/well-architected-framework/define-and-automate-processes/define/policy) to enforce VCS standards

## Next steps

In this section of [Codify infrastructure and tools](/well-architected-framework/define-and-automate-processes/define/as-code), you learned how to define your version control systems using infrastructure as code to enable version control and audit capabilities for VCS changes. Define your version control systems is part of the [Define and automate processes pillar](/well-architected-framework/define-and-automate-processes).