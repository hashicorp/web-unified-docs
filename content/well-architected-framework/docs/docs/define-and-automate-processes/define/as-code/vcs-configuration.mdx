---
page_title: Manage VCS configuration as code
description: Manage version control system configuration as code using Terraform GitHub or GitLab providers to ensure consistent repository settings and enable automation.
---

# Manage VCS configuration as code

Manually configuring version control systems creates inconsistent repository settings, security gaps, and configuration drift. Managing VCS configuration as code with Terraform standardizes repository settings, enforces security policies, and automates team and permission management across your organization.

Version control systems (VCS) like GitHub, GitLab, and Bitbucket store and version your infrastructure code, application code, and configuration files. While teams use VCS to manage infrastructure as code, the VCS platforms themselves require configuration including repository settings, branch protections, team permissions, and security controls. Terraform manages both on-premises VCS installations and cloud-based VCS platforms.

## Why manage VCS configuration as code

Managing VCS configuration as code addresses critical operational and security challenges:

- **Enforce security policies:** Apply branch protection rules, approval requirements, and access controls consistently across all repositories from creation.

- **Prevent configuration drift:** Ensure identical baseline configurations across repositories with variations defined in code rather than through manual changes.

- **Automate access management:** Eliminate manual management of team membership and repository permissions. Define and review access for your entire organization in code.

- **Meet audit and compliance requirements:** Create comprehensive audit trails through version control history, pull request reviews, and approval workflows instead of limited web interface logs.

## Manage GitHub configuration

The following example shows Terraform managing GitHub repository configuration, including branch protection rules and team permissions:

<CodeBlockConfig filename="github.tf">

```hcl
terraform {
  required_providers {
    github = {
      source  = "integrations/github"
      version = "~> 6.1"
    }
  }
}

provider "github" {
  owner = "your-organization"
}

# Create repository with standard configuration
resource "github_repository" "infrastructure" {
  name        = "infrastructure-production"
  description = "Production infrastructure as code"
  visibility  = "private"
  auto_init   = true
}

# Enforce branch protection on main branch
resource "github_branch_protection" "main" {
  repository_id = github_repository.infrastructure.node_id
  pattern       = "main"

  # Require pull request reviews
  required_pull_request_reviews {
    required_approving_review_count = 2
  }

  # Prevent force pushes and deletions
  allows_force_pushes = false
  allows_deletions    = false
}

# Create team with repository access
resource "github_team" "platform" {
  name        = "platform-engineering"
  description = "Platform engineering team"
  privacy     = "closed"
}

# Assign team permissions to repository
resource "github_team_repository" "platform_infra" {
  team_id    = github_team.platform.id
  repository = github_repository.infrastructure.name
  permission = "maintain"
}
```

</CodeBlockConfig>

This configuration creates a repository with security best practices enabled, enforces branch protection requiring two approvals before merging, and assigns team permissions. To learn more about each of the resources used in this example, refer to the [GitHub provider documentation](https://registry.terraform.io/providers/integrations/github/latest/docs).

## Manage GitLab configuration

The following example shows Terraform managing GitLab project configuration with merge request approvals and protected branches:

<CodeBlockConfig filename="gitlab.tf">

```hcl
terraform {
  required_providers {
    gitlab = {
      source  = "gitlabhq/gitlab"
      version = "~> 18.8"
    }
  }
}

provider "gitlab" {
  token = var.gitlab_token
}

# Create GitLab group for organization
resource "gitlab_group" "platform" {
  name             = "platform-engineering"
  path             = "platform"
  description      = "Platform engineering infrastructure"
  visibility_level = "private"
}

# Create project with standard settings
resource "gitlab_project" "infrastructure" {
  name             = "infrastructure-production"
  namespace_id     = gitlab_group.platform.id
  description      = "Production infrastructure as code"
  visibility_level = "private"

  # Require successful pipeline before merging
  only_allow_merge_if_pipeline_succeeds = true
}

# Protect main branch
resource "gitlab_branch_protection" "main" {
  project            = gitlab_project.infrastructure.id
  branch             = "main"
  push_access_level  = "no one"
  merge_access_level = "maintainer"
}

# Require approvals for merge requests
resource "gitlab_project_approval_rule" "security" {
  project            = gitlab_project.infrastructure.id
  name               = "Security review required"
  approvals_required = 2
  group_ids          = [gitlab_group.platform.id]
}
```

</CodeBlockConfig>

This configuration creates a GitLab project that requires pipeline success before merging, protects the main branch from direct pushes, and enforces approval requirements through code. To learn more about each of the resources used in this example, refer to the [GitLab provider documentation](https://registry.terraform.io/providers/gitlabhq/gitlab/latest/docs).

## HashiCorp resources:

- Learn to [define infrastructure as code](/well-architected-framework/define-and-automate-processes/define/as-code/infrastructure) to manage VCS platforms consistently
- Store code in [version control](/well-architected-framework/define-and-automate-processes/define/version-control) for infrastructure and application code
- Learn to [manage GitHub users, teams, and repository permissions](/terraform/tutorials/it-saas/github-user-teams) with Terraform

GitHub provider documentation:

- Read the [GitHub provider documentation](https://registry.terraform.io/providers/integrations/github/latest/docs) for complete configuration options
- Explore [repository resources](https://registry.terraform.io/providers/integrations/github/latest/docs/resources/repository) to configure repository settings
- Configure [branch protection](https://registry.terraform.io/providers/integrations/github/latest/docs/resources/branch_protection) to enforce security policies
- Manage [teams](https://registry.terraform.io/providers/integrations/github/latest/docs/resources/team) and [team repository permissions](https://registry.terraform.io/providers/integrations/github/latest/docs/resources/team_repository)

GitLab provider documentation:

- Read the [GitLab provider documentation](https://registry.terraform.io/providers/gitlabhq/gitlab/latest/docs) for complete configuration options
- Configure [projects](https://registry.terraform.io/providers/gitlabhq/gitlab/latest/docs/resources/project) and [groups](https://registry.terraform.io/providers/gitlabhq/gitlab/latest/docs/resources/group)
- Set up [branch protection](https://registry.terraform.io/providers/gitlabhq/gitlab/latest/docs/resources/branch_protection) to secure branches
- Configure [approval rules](https://registry.terraform.io/providers/gitlabhq/gitlab/latest/docs/resources/project_approval_rule) for merge requests

## Next steps

In this section of [Codify infrastructure and tools](/well-architected-framework/define-and-automate-processes/define/as-code), you learned how to define version control systems using infrastructure as code to enable version control and audit capabilities for VCS changes. Define version control systems is part of the [Define and automate processes pillar](/well-architected-framework/define-and-automate-processes).

After managing VCS configuration as code, apply these practices:

- Use [Terraform modules](/well-architected-framework/define-and-automate-processes/define/modules) to create reusable repository templates with standard security settings.
- Implement [policy as code](/well-architected-framework/define-and-automate-processes/define/policy) to validate VCS configurations before applying changes.