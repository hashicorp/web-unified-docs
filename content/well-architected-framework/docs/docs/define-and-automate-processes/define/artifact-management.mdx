---
page_title: Manage artifact repositories as code
description: Configure artifact repositories like Artifactory and Nexus as code to standardize dependency management, enforce security policies, and ensure consistent package access across teams.
---

# Manage artifact repositories as code

Manually configuring artifact repositories through web interfaces creates inconsistent settings across environments, security gaps in access control, and configuration drift as teams make ad-hoc changes. Managing artifact repositories as code with Terraform enables you to standardize repository configuration, enforce access policies, automate proxy setup for package managers, and ensure consistent artifact management across your organization. After [centralizing your packages and dependencies](/well-architected-framework/define-and-automate-processes/define/centralize-packages), you can codify your artifact repository configuration to maintain consistency and enable version-controlled changes.

Artifact repositories like JFrog Artifactory, Sonatype Nexus, and Azure Artifacts serve as central hubs for build artifacts and dependency packages. While teams use these repositories to store and retrieve packages, the repositories themselves require configurationâ€”repository creation, access control, proxy settings, and retention policies. Terraform can manage artifact repository configuration across different platforms, ensuring consistent setup and enabling infrastructure as code practices for your build infrastructure.

## Why manage artifact repositories as code

Managing artifact repository configuration as code addresses the following operational and security challenges:

- **Eliminate configuration drift across environments:** Manually creating repositories and configuring settings through web UIs results in development, staging, and production environments with different configurations. Managing repositories as code ensures identical configuration across all environments, with variations defined explicitly in code rather than accumulated through manual changes.

- **Enforce consistent security policies:** When teams manually configure repository permissions, access control policies diverge across repositories, creating security gaps where sensitive artifacts lack proper protection. Terraform enforces consistent access control, scanning policies, and artifact retention rules across all repositories from a single configuration.

- **Reduce repository management overhead:** Manually creating repositories for each team, application, and package type consumes significant administrative time and creates inconsistencies. Terraform automates repository creation and configuration, enabling you to provision dozens of repositories with standardized settings in minutes rather than hours.

- **Enable audit and compliance tracking:** Compliance frameworks require audit trails showing who made repository configuration changes and when. Manual configuration changes through web interfaces provide limited audit capabilities, while Terraform configurations stored in version control create comprehensive audit trails with commit history and approval workflows.

## Configure Artifactory with Terraform

The following example shows Terraform managing JFrog Artifactory repository configuration, including Docker and npm repositories with access control:

<CodeBlockConfig filename="artifactory.tf">

```hcl
terraform {
  required_providers {
    artifactory = {
      source  = "jfrog/artifactory"
      version = "~> 10.0"
    }
  }
}

provider "artifactory" {
  url          = "https://artifactory.example.com"
  access_token = var.artifactory_token
}

# Create Docker registry for application images
resource "artifactory_local_docker_v2_repository" "apps" {
  key         = "docker-apps-local"
  description = "Local Docker registry for application images"

  # Enable content scanning
  xray_index = true

  # Retention policy
  property_sets = ["artifactory"]
}

# Create npm repository for JavaScript packages
resource "artifactory_local_npm_repository" "frontend" {
  key         = "npm-frontend-local"
  description = "Local npm registry for frontend packages"

  # Enable indexing for search
  xray_index = true
}

# Create remote repository proxy for npm packages
resource "artifactory_remote_npm_repository" "npmjs" {
  key         = "npm-remote"
  description = "Proxy for npmjs.com to cache dependencies"
  url         = "https://registry.npmjs.org"

  # Cache retrieved packages
  retrieval_cache_period_seconds = 86400
}

# Create virtual repository combining local and remote
resource "artifactory_virtual_npm_repository" "npm" {
  key         = "npm"
  description = "Virtual npm registry combining local and cached packages"

  repositories = [
    artifactory_local_npm_repository.frontend.key,
    artifactory_remote_npm_repository.npmjs.key
  ]

  # Use local first, fall back to remote
  default_deployment_repo = artifactory_local_npm_repository.frontend.key
}

# Configure access permissions
resource "artifactory_permission_target" "frontend_team" {
  name = "frontend-team-permissions"

  repo {
    includes_pattern = ["**"]
    repositories     = [artifactory_virtual_npm_repository.npm.key]

    actions {
      users {
        name        = "frontend-ci"
        permissions = ["read", "write", "annotate"]
      }

      groups {
        name        = "frontend-developers"
        permissions = ["read", "write"]
      }
    }
  }
}
```

</CodeBlockConfig>

This configuration creates a Docker registry and npm repository with caching proxy, combines them in a virtual repository, and assigns team-based permissions. When you apply this configuration, Terraform provisions repositories with consistent settings that match organizational standards. Teams use the virtual repository URL to publish and retrieve packages, with Artifactory automatically caching external dependencies for offline availability.

## Configure Nexus Repository with Terraform

The following example shows Terraform managing Sonatype Nexus Repository configuration for Maven and Docker artifacts:

<CodeBlockConfig filename="nexus.tf">

```hcl
terraform {
  required_providers {
    nexus = {
      source  = "datadrivers/nexus"
      version = "~> 2.0"
    }
  }
}

provider "nexus" {
  url      = "https://nexus.example.com"
  username = var.nexus_username
  password = var.nexus_password
}

# Create hosted Maven repository
resource "nexus_repository_maven_hosted" "releases" {
  name   = "maven-releases"
  online = true

  storage {
    blob_store_name                = "default"
    strict_content_type_validation = true
    write_policy                   = "ALLOW_ONCE"
  }

  maven {
    version_policy      = "RELEASE"
    layout_policy       = "STRICT"
    content_disposition = "INLINE"
  }
}

# Create proxy repository for Maven Central
resource "nexus_repository_maven_proxy" "central" {
  name   = "maven-central-proxy"
  online = true

  storage {
    blob_store_name = "default"
  }

  proxy {
    remote_url       = "https://repo1.maven.org/maven2/"
    content_max_age  = 1440
    metadata_max_age = 1440
  }

  negative_cache {
    enabled = true
    ttl     = 1440
  }

  http_client {
    blocked    = false
    auto_block = true
  }

  maven {
    version_policy = "RELEASE"
    layout_policy  = "STRICT"
  }
}

# Create group repository combining hosted and proxy
resource "nexus_repository_maven_group" "public" {
  name   = "maven-public"
  online = true

  group {
    member_names = [
      nexus_repository_maven_hosted.releases.name,
      nexus_repository_maven_proxy.central.name
    ]
  }

  storage {
    blob_store_name = "default"
  }
}

# Create Docker hosted repository
resource "nexus_repository_docker_hosted" "apps" {
  name   = "docker-apps"
  online = true

  docker {
    v1_enabled      = false
    force_basic_auth = true
    http_port        = 5000
  }

  storage {
    blob_store_name                = "default"
    strict_content_type_validation = true
    write_policy                   = "ALLOW"
  }
}

# Configure cleanup policy for old snapshots
resource "nexus_cleanup_policy" "snapshots" {
  name        = "cleanup-old-snapshots"
  format      = "maven2"
  description = "Remove snapshot artifacts older than 30 days"

  criteria {
    last_downloaded = 30
    regex           = ".*-SNAPSHOT"
  }
}
```

</CodeBlockConfig>

This configuration creates Maven repositories (hosted, proxy, and group) and a Docker registry, implements cleanup policies for old snapshots, and configures caching for external dependencies. Teams configure their Maven settings or Dockerfile to use these repository URLs, with Nexus automatically caching dependencies and enforcing retention policies.

## Integrate artifact repositories with CI/CD

After configuring artifact repositories as code, integrate them with your CI/CD pipelines to automate artifact publishing and retrieval. The following example shows GitHub Actions publishing npm packages to Artifactory:

<CodeBlockConfig filename=".github/workflows/publish.yml">

```yaml
name: Build and Publish Package

on:
  push:
    branches: [main]

jobs:
  publish:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          registry-url: 'https://artifactory.example.com/artifactory/api/npm/npm'

      - name: Install dependencies
        run: npm ci

      - name: Run tests
        run: npm test

      - name: Build package
        run: npm run build

      - name: Publish to Artifactory
        run: npm publish
        env:
          NODE_AUTH_TOKEN: ${{ secrets.ARTIFACTORY_TOKEN }}
```

</CodeBlockConfig>

This GitHub Actions workflow builds and tests npm packages, then publishes them to Artifactory using credentials stored in GitHub Secrets. The workflow uses Artifactory as the npm registry URL, ensuring all published packages go through your centralized artifact repository where they can be scanned for vulnerabilities and cached for team access.

## HashiCorp resources

- [Centralize packages and dependencies](/well-architected-framework/define-and-automate-processes/define/centralize-packages) to understand artifact management concepts
- [Define infrastructure as code](/well-architected-framework/define-and-automate-processes/define/as-code/infrastructure) to provision artifact repositories consistently
- [Use version control](/well-architected-framework/define-and-automate-processes/define/version-control) to track artifact repository configuration changes

Get started with Terraform for artifact management:

- Learn Terraform with the [Terraform tutorials](/terraform/tutorials) and read the [Terraform documentation](/terraform/docs)
- Browse [Terraform providers](/terraform/docs/providers) for artifact repository platforms

Artifact repository provider documentation:

- Read the [Artifactory provider documentation](https://registry.terraform.io/providers/jfrog/artifactory/latest/docs) for JFrog Artifactory configuration
- Read the [Nexus provider documentation](https://registry.terraform.io/providers/datadrivers/nexus/latest/docs) for Sonatype Nexus configuration
- Explore [Azure Artifacts](https://registry.terraform.io/providers/hashicorp/azuredevops/latest/docs/resources/feed) for Azure-based artifact management

Secrets management for artifact repositories:

- Learn about [Vault dynamic secrets](/vault/tutorials/db-credentials/database-secrets) to generate temporary artifact repository credentials
- Use [Vault with Terraform](/vault/tutorials/encryption-as-a-service/terraform-secrets-engine) to securely manage artifact repository access tokens

External resources:

- Read about [artifact repository best practices](https://www.sonatype.com/resources/white-paper-repository-best-practices) from Sonatype
- Learn about [dependency management strategies](https://jfrog.com/blog/dependency-management-best-practices/) from JFrog

## Next steps

In this section of Define your processes, you learned how to manage artifact repository configuration as code to standardize dependency management, enforce security policies, and ensure consistent package access. You explored how Terraform configures Artifactory and Nexus repositories with access control, proxying, and retention policies. Manage artifact repositories as code is part of the [Define and automate processes pillar](/well-architected-framework/define-and-automate-processes).

Visit the following documents to continue building your automation strategy:

- [Implement CI/CD](/well-architected-framework/define-and-automate-processes/automate/cicd) to automate artifact publishing and deployment
- [Create reusable modules](/well-architected-framework/define-and-automate-processes/define/modules) to standardize artifact repository configurations
- [Implement testing](/well-architected-framework/define-and-automate-processes/automate/testing) to validate artifact repository configurations
