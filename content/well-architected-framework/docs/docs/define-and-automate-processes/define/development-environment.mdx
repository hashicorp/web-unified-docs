---
page_title: Use consistent development environments
description: Create consistent development environments that mirror production to eliminate environment-related issues, improve deployment reliability, and reduce onboarding time.
---

# Use consistent development environments

Environment inconsistencies between development, testing, and production cause deployment failures that are difficult to diagnose. When developers work with different operating systems, dependency versions, or configurations, code that works in development fails in production. These discrepancies waste time troubleshooting environment-specific issues rather than building features.

Standardizing development environments addresses operational challenges by ensuring consistent behavior across development, testing, and production. Vagrant allows you to define development environments as code, creating reproducible environments that match production configurations. When production environments change, you update the environment definition and developers rebuild their environments to match.

## Why standardize development environments

Standardized development environments address the following operational challenges:

- **Eliminate environment-specific bugs:** Applications behave differently across environments when teams use varying operating systems, library versions, or configurations. Environment parity ensures code tested in development works the same way in production, reducing deployment failures.

- **Reduce onboarding time for new developers:** New team members spend hours or days configuring local development environments when setup is manual and undocumented. Automated environment provisioning gets developers productive immediately by providing pre-configured, working environments.

- **Prevent dependency conflicts and version mismatches:** Manual dependency installation leads to version inconsistencies between developers and environments. Codified environment definitions specify exact versions, eliminating "works on my machine" problems.

- **Enable environment updates without manual coordination:** When infrastructure requirements change, notifying all developers to update their environments manually is error-prone and time-consuming. Version-controlled environment configurations allow developers to pull updates and rebuild environments automatically.

## Implement consistent environments with Vagrant

Vagrant defines development environments in a configuration file called a Vagrantfile. The Vagrantfile specifies the base operating system, installed software, network configuration, and provisioning scripts needed to create a complete development environment. When a developer runs `vagrant up`, Vagrant builds and configures a virtual machine matching the Vagrantfile specification.

Vagrant uses providers like VirtualBox, VMware, or Docker to create virtual machines. Provisioners like Shell scripts, Ansible, or Chef configure the virtual machine after creation. The Vagrantfile can specify port forwarding, shared folders, and resource allocation to match development needs.

The following example shows a Vagrantfile that creates a complete development environment for a web application:

<CodeBlockConfig filename="Vagrantfile">

```ruby
Vagrant.configure("2") do |config|
  # Use Ubuntu 20.04 LTS as base image
  config.vm.box = "ubuntu/focal64"

  # Allocate resources matching production environment
  config.vm.provider "virtualbox" do |vb|
    vb.memory = "4096"
    vb.cpus = 2
  end

  # Forward application port to host machine
  config.vm.network "forwarded_port", guest: 8080, host: 8080
  config.vm.network "forwarded_port", guest: 5432, host: 5432

  # Sync application code to VM
  config.vm.synced_folder "./app", "/opt/application"

  # Provision environment with shell script
  config.vm.provision "shell", inline: <<-SHELL
    # Update package list
    apt-get update

    # Install application dependencies
    apt-get install -y \
      docker.io \
      docker-compose \
      postgresql-12 \
      postgresql-client \
      nginx

    # Configure PostgreSQL for development
    sudo -u postgres psql -c "CREATE DATABASE app_development;"
    sudo -u postgres psql -c "CREATE USER app_user WITH PASSWORD 'dev_password';"
    sudo -u postgres psql -c "GRANT ALL PRIVILEGES ON DATABASE app_development TO app_user;"

    # Start services
    systemctl enable docker
    systemctl start docker
    systemctl enable postgresql
    systemctl start postgresql

    # Copy application configuration
    cp /opt/application/nginx.conf /etc/nginx/sites-available/app
    ln -s /etc/nginx/sites-available/app /etc/nginx/sites-enabled/
    systemctl restart nginx

    echo "Development environment ready!"
    echo "Application: http://localhost:8080"
    echo "Database: postgresql://app_user:dev_password@localhost:5432/app_development"
  SHELL
end
```

</CodeBlockConfig>

This Vagrantfile creates a production-like development environment with allocated resources (4GB RAM, 2 CPUs), forwards application and database ports, syncs application code into the VM, and provisions a complete stack including Docker, PostgreSQL, and Nginx. The shell provisioner configures the database, creates users, and starts services. Developers run `vagrant up` to create the environment, `vagrant ssh` to access it, and `vagrant destroy` to remove it. The consistent environment definition ensures all team members work with identical configurations that mirror production infrastructure.

HashiCorp resources:

- [Standardize workflows](/well-architected-framework/define-and-automate-processes/define/standardize-workflows) to create consistent processes across teams
- [Use version control](/well-architected-framework/define-and-automate-processes/define/version-control) to track changes to environment definitions
- [Map your workflows](/well-architected-framework/define-and-automate-processes/define/workflows) to document your development workflow

Get started with Vagrant:

- Learn Vagrant with the [Vagrant tutorials](/vagrant/tutorials/getting-started) and read the [Vagrant documentation](/vagrant/docs)
- Follow the [Vagrant getting started guide](/vagrant/tutorials/getting-started) for hands-on environment creation
- Read about [Vagrant provisioners](/vagrant/docs/provisioning) to automate environment configuration

Vagrant advanced features:

- Use [Vagrant with Packer](/packer/tutorials/aws-get-started/aws-get-started-post-processors-vagrant) to create consistent VM images
- Configure [Vagrant networking](/vagrant/docs/networking) for complex environment setups
- Learn about [Vagrant synced folders](/vagrant/docs/synced-folders) to share code between host and VM
- Use [Vagrant with Docker](/vagrant/docs/providers/docker) for container-based development environments

External resources:

- Read about [development environment best practices](https://12factor.net/dev-prod-parity) from the Twelve-Factor App methodology
- Learn about [infrastructure parity](https://docs.docker.com/develop/dev-best-practices/) for development and production environments

## Next steps

In this section, you learned how to create consistent development environments that mirror production to eliminate environment-related issues. You explored how Vagrant defines environments as code and how standardized environments reduce onboarding time and prevent deployment failures. Use consistent development environments is part of the [Define and automate processes pillar](/well-architected-framework/define-and-automate-processes).

Visit the following documents to continue improving your development workflow:

- [Implement CI/CD](/well-architected-framework/define-and-automate-processes/automate/cicd) to automate testing in standardized environments
- [Create reusable modules](/well-architected-framework/define-and-automate-processes/define/modules) to standardize infrastructure components across environments