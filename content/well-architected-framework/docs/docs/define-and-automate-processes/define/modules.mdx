---
page_title: Create reusable infrastructure modules
description: Create reusable Terraform modules to standardize infrastructure, enforce security policies across teams, and accelerate deployment while reducing duplication.
---

# Create reusable infrastructure modules

A Terraform module is a container for multiple infrastructure resources that you manage as a single unit. Modules let you package infrastructure configurations into reusable components—essentially infrastructure templates or libraries—that teams can share across your organization. These reusable patterns reduce deployment time, enforce security standards, and eliminate configuration duplication. You can design modules to comply with organizational best practices and ensure consistent infrastructure across environments. After [mapping your current workflows](/well-architected-framework/define-and-automate-processes/define/workflows) and defining your infrastructure as code, you can extract repeated patterns into modules and share them through registries for team-wide use.

## Why create reusable modules

Creating reusable infrastructure modules—also known as infrastructure abstractions or packaged components—addresses the following strategic operational and security challenges:

- **Remove deployment inconsistencies:** Manual infrastructure provisioning creates configuration drift between environments. Modules enforce consistent configuration across all deployments.

- **Reduce security policy violations:** Teams deploying infrastructure without standardized security controls increase your organization's risk exposure. Each manual deployment requires security review and validation. Modules encode security best practices once and apply them consistently across all implementations.

- **Increase developer productivity:** Developers don't have to write infrastructure as code from scratch. They can reuse existing infrastructure building blocks to provision infrastructure instead of spending time researching and writing new code.

## When to use modules

Use modules in the following scenarios:

- You deploy the same group of resources multiple times with minor variations
- You need to enforce organizational standards and security policies across deployments
- Multiple teams need to provision similar infrastructure
- You need to maintain consistency across development, staging, and production environments

You might not need reusable modules in the following cases:

- One-time infrastructure deployments
- Highly customized configurations
- Prototype infrastructure that changes frequently

## Create Terraform modules

A Terraform module is a set of Terraform configuration files in a single directory. Modules are reusable and customizable and you can wrap modules with configurations to fit your organization's standards. You can create modules for common infrastructure patterns that your teams use frequently, following the DRY (Don't Repeat Yourself) principle to reduce duplication.

For example, if your team manages object storage for multiple applications that all follow your organization's common standards, such as security or lifecycle management, you can use an object storage Terraform module for your cloud providers. The object storage module can contain configuration such as lifecycle policies or security standards. After creating modules, store them in version control alongside your infrastructure code to track changes. You can then publish modules to a registry for distribution and versioning.

To learn how to create Terraform modules, read the [Module development](/terraform/language/modules/develop) documentation.

### Create a module

A Terraform module consists of Terraform configuration files in a dedicated directory. Modules typically include input variables, resource definitions, and output values. The following example shows a VPC module structure:

```text
modules/
└── vpc/
    ├── main.tf       # Resource definitions
    ├── variables.tf  # Input variables
    └── outputs.tf    # Output values
```

The following example shows a complete VPC module that creates a VPC with configurable CIDR block and environment tagging:

<CodeBlockConfig filename="modules/vpc/main.tf">

```hcl
resource "aws_vpc" "main" {
  cidr_block           = var.cidr_block
  enable_dns_hostnames = true
  enable_dns_support   = true

  tags = {
    Name        = "${var.environment}-vpc"
    Environment = var.environment
  }
}

resource "aws_internet_gateway" "main" {
  vpc_id = aws_vpc.main.id

  tags = {
    Name        = "${var.environment}-igw"
    Environment = var.environment
  }
}
```

</CodeBlockConfig>

<CodeBlockConfig filename="modules/vpc/variables.tf">

```hcl
variable "environment" {
  description = "Environment name (e.g., production, staging, development)"
  type        = string
}

variable "cidr_block" {
  description = "CIDR block for the VPC"
  type        = string
  default     = "10.0.0.0/16"
}
```

</CodeBlockConfig>

<CodeBlockConfig filename="modules/vpc/outputs.tf">

```hcl
output "vpc_id" {
  description = "The ID of the VPC"
  value       = aws_vpc.main.id
}

output "internet_gateway_id" {
  description = "The ID of the Internet Gateway"
  value       = aws_internet_gateway.main.id
}
```

</CodeBlockConfig>

After creating the module, you can call it from your root configuration by referencing the module directory:

<CodeBlockConfig filename="main.tf">

```hcl
module "production_vpc" {
  source      = "./modules/vpc"
  environment = "production"
  cidr_block  = "10.0.0.0/16"
}

module "staging_vpc" {
  source      = "./modules/vpc"
  environment = "staging"
  cidr_block  = "10.1.0.0/16"
}

# Use module outputs in other resources
resource "aws_subnet" "production_public" {
  vpc_id     = module.production_vpc.vpc_id
  cidr_block = "10.0.1.0/24"
}
```

</CodeBlockConfig>

This configuration creates two VPCs using the same module with different inputs. The module encapsulates VPC creation logic, ensuring consistent configuration across environments. Module outputs provide values that other resources can reference, creating connections between infrastructure components.

## Use the Terraform Registry

The Terraform Registry is a centralized source for finding providers and their supporting documentation. You can find official, partner, and community providers, modules, policy libraries, and run tasks in the Terraform Registry. The Terraform Registry is a great first step in learning all the resources you can manage with Terraform.

You can find publicly available Terraform modules for configuring many kinds of common infrastructure in the Terraform Registry. These modules are free to use, and Terraform can download them automatically if you specify the appropriate source and version in a module block (a `module` configuration block in your Terraform code).

Your organization may produce modules tailored for your own infrastructure needs. HCP Terraform and Terraform Enterprise both include a private module registry which is a secure and internal repository, for sharing modules within your organization without publishing them publicly.

## Version your modules

Module versioning ensures stability and predictability in your infrastructure deployments. When you version your modules, you can update them without breaking existing deployments.

Use the following best practices for module versioning:

- Use semantic versioning, such as v1.2.3. Semantic versioning uses three numbers: major version for breaking changes, minor version for new features, and patch version for bug fixes
- Tag releases in your version control system to mark stable versions
- Document breaking changes in release notes
- Pin module versions in production environments to prevent unexpected updates

### Specify module versions

When calling modules from a registry, you can use version constraints to specify the version to ensure consistent deployments. The following shows two examples of version constraints in a module block. The first example pins the module to an exact version, while the second example uses a pessimistic constraint to allow patch updates only.

```hcl
module "vpc" {
  source  = "terraform-aws-modules/vpc/aws"
  version = "5.0.0"

  name = "my-vpc"
  cidr = "10.0.0.0/16"
}
```

This configuration pins the VPC module to version 5.0.0 exactly. Terraform always downloads this specific version from the registry, ensuring consistent infrastructure across all deployments.


```hcl
module "vpc" {
  source  = "terraform-aws-modules/vpc/aws"
  version = "~> 5.0.0"  # Allow patch updates only

  name = "my-vpc"
  cidr = "10.0.0.0/16"
}
```

The pessimistic constraint operator `~>` allows Terraform to automatically download compatible updates. The version `~> 5.0.0` permits updates to 5.0.1, 5.0.2, and so on, but blocks updates to 5.1.0 or 6.0.0.

## HashiCorp resources

- Define [infrastructure as code](/well-architected-framework/define-and-automate-processes/define/as-code/infrastructure) to understand IaC principles before creating modules
- Store code in [version control](/well-architected-framework/define-and-automate-processes/define/version-control) to track and version modules

Learn how to write Terraform modules:

- Learn Terraform with the [Terraform tutorials](/terraform/tutorials) and read the [Terraform documentation](/terraform/docs)
- Follow the [Terraform style guide](https://developer.hashicorp.com/terraform/language/style-guide) to follow Terraform style conventions

Learn about Terraform modules:

- Learn about [module development](/terraform/language/modules/develop) to create custom modules
- Follow [module tutorials](/terraform/tutorials/modules) for hands-on module examples
- Browse the [Terraform Registry](https://registry.terraform.io/browse/modules) for community modules
- Read about [module sources](/terraform/language/modules/sources) for different module locations
- Learn about [Sentinel policies](/terraform/cloud-docs/policy-enforcement) to enforce module standards
- Use the [HCP Terraform private registry](/terraform/cloud-docs/registry) to share modules across your organization

External resources:

- Learn about [semantic versioning](https://semver.org/) to version your modules effectively.

## Next steps

In this section of Define your processes, you learned about using Terraform modules to standardize your infrastructure deployments. This topic is part of the [Define and automate processes pillar](/well-architected-framework/define-and-automate-processes).

Refer to the following documents to learn more about infrastructure automation:

- [CI/CD](/well-architected-framework/define-and-automate-processes/automate/cicd) to implement automation for infrastructure and applications
- [Testing](/well-architected-framework/define-and-automate-processes/automate/testing) to implement testing for infrastructure and applications
- [Deployment](/well-architected-framework/define-and-automate-processes/automate/deployments) to implement deployment for infrastructure and applications
- [Packaging](/well-architected-framework/define-and-automate-processes/automate/packaging) to package applications for deployment 