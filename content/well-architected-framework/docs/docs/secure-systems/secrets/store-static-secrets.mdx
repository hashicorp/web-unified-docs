---
page_title: Secure your static secrets with key/value storage
description: Secure passwords, API keys, and certificates with proper access control. Learn how key/value storage protects your organization's sensitive data.
---

# Secure your static secrets with key/value storage

A static secret is any sensitive credential, such as a password or API key, that you create and maintain over a long period of time. The secret value remains the same until you change or rotate it. Securing static secrets protects your organization from data breaches and unauthorized access to critical systems. Organizations classify these credentials as restricted because compromised secrets can cause severe damage, including data loss, security breaches, and compliance violations.

## Protect your organization with secure secret storage

While you often classify secrets as restricted, you still need to use these secrets to access systems or configure applications to access other services using the secret. Because both individual users and applications require access to these secrets, securely storing them with proper authentication and authorization is critical to your organization's security posture and reputation.

HashiCorp Vault's key/value (KV) secrets engine allows you to store any type of arbitrary secret such as usernames, passwords, API keys, and even static TLS certificates that are not able to be automatically provisioned by base64 encoding the certificate.

You can protect and manage access to the secrets stored in Vault's KV secrets engine using Vault's robust access control policy framework, and incorporate advanced Sentinel policies to ensure only authorized individuals or applications access the secrets they are entitled to.

<VideoEmbed url="https://www.youtube.com/watch?v=QAzSI0o24aQ"/>

Vault is available as a self-hosted application, or you can get started with Vault quickly using the [HashiCorp Cloud Platform](https://portal.cloud.hashicorp.com/sign-in). Sentinel integrates with both self-hosted Vault or HCP Vault Dedicated.

## Store static secrets with Vault

Before you deploy Vault, take time to plan a KV storage architecture to ensure teams and applications (clients) have access based on your organization's security requirements. You can store all secrets in a single instance of the KV secrets engine, or enable multiple KV secrets at unique paths.

Once you have solidified your plan for the KV secrets engine, enable the secrets engine using your Vault administrator's preferred tools. Vault supports a command line interface (CLI), application programming interface (API), web based user interface (UI), HashiCorp Terraform, and many other configuration management tools such as Ansible.

Once you have enabled the KV secrets engine, and assigned an appropriately scoped policy to a client, any authenticated client assigned the policy can interact with the secret based on the policy. You can learn how to enable the KV secrets engine, write a policy, and assign it to a client using the UI, CLI, API, and Terraform in the Vault get started series of tutorials.

## Choose between KV v1 and KV v2

Vault provides two versions of the key/value secrets engine with different capabilities. Understanding the differences helps you choose the right version for your security requirements and operational needs.

| Feature | KV v2 | KV v1 |
|---------|-------|-------|
| **Versioning** | Multiple versions of each secret | No versioning |
| **Metadata** | Custom metadata, created/updated timestamps | No metadata support |
| **Soft delete** | Secrets can be undeleted | Permanent deletion only |
| **Check-and-set** | Prevents concurrent write conflicts | No concurrency protection |
| **Storage overhead** | Moderate (stores version history) | Low (single value only) |
| **Recommended for** | Production environments, compliance requirements | Simple configuration storage |
| **Path format** | `kv/data/path` (read), `kv/metadata/path` (metadata) | `kv/path` |

**Recommendation:** Use KV v2 for production secrets and any environment requiring audit trails, version history, or the ability to recover from accidental deletions. The versioning and metadata capabilities provide significant operational and compliance benefits that outweigh the modest storage overhead. Use KV v1 only for simple configuration data where versioning is not required.

## Configuration examples

The following examples demonstrate how to enable the KV secrets engine, store secrets, and retrieve them using both the CLI and API.

**Enable KV v2 secrets engine:**

```bash
# Enable KV v2 at the default 'secret/' path
vault secrets enable -version=2 kv

# Or enable at a custom path
vault secrets enable -path=myapp -version=2 kv
```

**Store secrets using the CLI:**

```bash
# Store a single secret
vault kv put kv/database/production password="secure-password-123"

# Store multiple key-value pairs
vault kv put kv/api/github \
  token="ghp_xxxxxxxxxxxx" \
  username="api-user" \
  base_url="https://api.github.com"

# Store secrets with check-and-set to prevent concurrent updates
vault kv put -cas=0 kv/database/production password="initial-password"
```

**Retrieve secrets using the CLI:**

```bash
# Get a specific field
vault kv get -field=password kv/database/production

# Get entire secret as JSON
vault kv get -format=json kv/api/github

# Get a specific version
vault kv get -version=2 kv/database/production

# List all secrets at a path
vault kv list kv/database
```

**Retrieve secrets using the API:**

```bash
# Read secret (note the /data/ in the path)
curl -H "X-Vault-Token: $VAULT_TOKEN" \
  https://vault.example.com:8200/v1/kv/data/database/production

# Read metadata (version history, custom metadata)
curl -H "X-Vault-Token: $VAULT_TOKEN" \
  https://vault.example.com:8200/v1/kv/metadata/database/production

# List secrets
curl -H "X-Vault-Token: $VAULT_TOKEN" \
  https://vault.example.com:8200/v1/kv/metadata/database?list=true
```

## Understanding KV v2 path structure

KV v2 uses different API paths for data operations versus metadata operations, which can cause confusion when working with the API directly. Understanding this path structure prevents common mistakes.

**CLI automatically handles paths:**

When you use the `vault kv` CLI commands, Vault automatically adds the appropriate path prefix:

```bash
# You write:
vault kv get kv/database/production

# Vault translates to:
# GET /v1/kv/data/database/production
```

**API requires explicit paths:**

When calling the Vault API directly, you must include the appropriate path prefix:

```bash
# Data operations use /data/ prefix
curl https://vault.example.com:8200/v1/kv/data/database/production

# Metadata operations use /metadata/ prefix
curl https://vault.example.com:8200/v1/kv/metadata/database/production
```

**Common mistake:** Forgetting the `/data/` prefix when calling the API results in a 404 error. If you receive unexpected 404 responses when the secret exists, verify you are using the correct path format for your access method.

## Best practices for static secrets

The following best practices help you maintain security and operational efficiency when managing static secrets in Vault.

**Organize secrets with a consistent hierarchy:**

Create a logical path structure that reflects your organization's structure, environments, or applications. A consistent hierarchy makes it easier to write policies, locate secrets, and manage access control.

```
kv/
├── prod/
│   ├── database/       # Production database credentials
│   ├── api-keys/       # Production API keys
│   └── certificates/   # Production TLS certificates
├── staging/
│   ├── database/
│   └── api-keys/
└── dev/
    └── test-data/
```

**Use versioning to track changes:**

KV v2 automatically versions secrets, allowing you to view secret history, roll back to previous versions, and audit when secrets changed. This capability is critical for compliance, debugging, and recovering from mistakes.

```bash
# View all versions of a secret
vault kv metadata get kv/database/production

# Roll back to a previous version
vault kv get -version=3 kv/database/production

# Configure maximum versions to retain
vault kv metadata put -max-versions=10 kv/database/production
```

**Implement regular secret rotation:**

Static secrets require manual rotation, unlike dynamic secrets that automatically expire. Establish a rotation schedule based on your security requirements and compliance obligations. Use KV v2 versioning during rotation to maintain both old and new secrets during a grace period.

```bash
# Rotation workflow
# 1. Generate new credential in external system
# 2. Store new version in Vault
vault kv put kv/api/github token="ghp_newtoken"

# 3. Update applications to use new credential
# 4. Revoke old credential in external system after grace period
```

**Configure access control with least-privilege policies:**

Grant clients read-only access to secrets they need, and deny capabilities that could cause data loss. Separate secrets by environment or sensitivity level to enable fine-grained access control.

```hcl
# Example policy for application read access
path "kv/data/prod/database/*" {
  capabilities = ["read", "list"]
}

# Deny delete and destroy to prevent data loss
path "kv/delete/prod/*" {
  capabilities = ["deny"]
}

path "kv/destroy/prod/*" {
  capabilities = ["deny"]
}

# Allow metadata read for version history
path "kv/metadata/prod/database/*" {
  capabilities = ["read", "list"]
}
```

**Use metadata to track secret ownership and rotation:**

KV v2 supports custom metadata that you can use to document secret ownership, rotation schedules, and criticality. This metadata improves operational visibility without exposing sensitive values.

```bash
# Add custom metadata
vault kv metadata put kv/database/production \
  custom_metadata=owner="platform-team" \
  custom_metadata=rotation_frequency="90d" \
  custom_metadata=criticality="high" \
  custom_metadata=last_rotated="2024-01-15"
```

**Validate secrets before use:**

Always validate that secrets exist and contain expected values before using them in production operations. This prevents failures from missing or malformed secrets.

```bash
# Check if secret exists
if vault kv get kv/database/production >/dev/null 2>&1; then
  PASSWORD=$(vault kv get -field=password kv/database/production)
else
  echo "ERROR: Secret not found"
  exit 1
fi

# Validate secret is not empty
if [ -z "$PASSWORD" ]; then
  echo "ERROR: Secret value is empty"
  exit 1
fi
```

## HashiCorp resources

- [Get started with Vault](/vault/tutorials/get-started)
- Watch the developers guide to [HCP Vault](https://www.youtube.com/watch?v=of_SwLDUjrg&list=PL81sUbsFNc5ZWoz3gpCJgUl3H7yZO_iE7)
- Read documentation on [Vault KV secrets engine](/vault/docs/secrets/kv)
- Learn how to use the [Vault K/V secrets engine](/vault/tutorials/secrets-management/versioned-kv).

### External resources

- [Secrets management](https://www.ibm.com/think/topics/secrets-management)

## Next steps

In this section of how to Secure secrets, you learned about how to store static secrets in your organization. Storing static secrets is part of the [Secure systems pillar](/well-architected-framework/secure-systems).
