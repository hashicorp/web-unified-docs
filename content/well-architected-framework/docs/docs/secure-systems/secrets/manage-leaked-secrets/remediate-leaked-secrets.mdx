---
page_title: Remediate leaked secrets
description: Remediate leaked secrets in documentation and source code following NIST incident response guidelines. Learn secure rotation and recovery strategies.
---

# Remediate leaked secrets

Once you identify a leaked secret and store it in your secrets manager, you need to plan to remediate the leaked secret.

If you have not already done so, form an incident response team. This team should include technical representatives from the security, operations, and development teams, as well as business and legal representatives.

The remediation process will vary based on the following factors:

- The type of system the leaked secret gives access to
- The type of data available in that system
- Whether you have to report the incident to a government or industry regulator

In any scenario, part of your remediation process should include communication with your stakeholders, both internal (such as development teams) and external (such as customers), to ensure they stay informed of any actions they may need to take.

## Why remediate leaked secrets immediately

**Exposed secrets enable unauthorized access within hours:** Once attackers discover leaked credentials, they typically exploit them within 24-48 hours. Delayed remediation allows attackers to establish persistence, exfiltrate data, or create backdoor access that remains even after you rotate the original secret.

**Breach notification timelines create legal liability:** Regulations like GDPR (72 hours), HIPAA (60 days), and state breach notification laws impose strict reporting deadlines. Organizations that fail to detect and remediate breaches promptly face significant fines and mandatory public disclosure.

**Incomplete remediation enables re-compromise:** Simply rotating a leaked secret without removing it from all locations allows attackers to re-compromise systems. Secrets remain in Git history, backups, logs, and documentation unless you systematically remove them from every location.

**Post-breach costs exceed prevention by 10x:** The average data breach costs $4.45 million, with incident response, forensics, legal fees, and customer notification consuming significant resources. Organizations that remediate quickly limit exposure and reduce total breach costs.

Systematic remediation following NIST incident response guidelines—containment, eradication, recovery, and post-incident review—minimizes business impact and prevents repeat incidents.

## Follow the NIST incident response framework

The National Institute of Standards and Technology (NIST) is a helpful resource for defining requirements for incident response. [NIST SP 800-61: Computer Security Incident Handling Guide](https://nvlpubs.nist.gov/nistpubs/specialpublications/nist.sp.800-61r2.pdf) identifies the following four stages of incident response:

1. **Preparation:** Ensure you have the right tools and processes in place to identify, manage, and remediate incidents.
1. **Detection and analysis:** Identify the incident, and analyze the impact of the incident.
1. **Containment, eradication, and recovery:** Contain the incident, remove the cause of the incident, and recover from the incident.
1. **Post-incident activity:** Review the incident, and update your processes to prevent similar incidents in the future.

## Remove leaked secrets from documentation

If you identify a leaked secret in documentation, the first step is to identify what teams, workflows, or applications depend on this secret. A common practice is to document requirements in a configuration management database (CMDB). Similarly, if you are using Terraform to manage your Vault policies, you can cross-reference the policies to determine what teams or applications are using the secret.

If the processes using the secret already retrieve the secret from Vault, complete the following steps:

- Rotate or change the secret
- Remove the plaintext secret from the documentation
- Update the secret value in Vault

Any process retrieving the secret will receive the updated secret value from Vault.

The following example shows how to rotate a leaked database password in HashiCorp Vault:

<CodeBlockConfig hideClipboard>

```bash
# Generate new secret value
NEW_SECRET=$(openssl rand -base64 32)

# Update secret in Vault
vault kv put secret/app/database password="$NEW_SECRET"

# Verify rotation
vault kv get secret/app/database
```

</CodeBlockConfig>

The rotation workflow updates a leaked database password in Vault's key-value store. Applications configured to read from Vault automatically receive the updated credential without code changes, eliminating downtime during rotation.

## Remediate secrets exposed in source code

When you identify a leaked secret in source code, the process is more involved and may require involving other teams.

If the application or workflow built from the source code requires access to this secret, you must update the source code to reference it in a secure manner.

The following example shows how to refactor application code from hardcoded secrets to runtime Vault retrieval:

<CodeBlockConfig hideClipboard>

```python
# Before: Secret hardcoded in source code
DATABASE_PASSWORD = "leaked-password-123"
db_connection = connect(host="db.example.com", password=DATABASE_PASSWORD)

# After: Retrieve secret from Vault at runtime
import hvac

client = hvac.Client(url='http://vault:8200')
client.token = client.auth.approle.login(role_id=ROLE_ID, secret_id=SECRET_ID)['auth']['client_token']

secret = client.secrets.kv.v2.read_secret_version(path='app/database')
DATABASE_PASSWORD = secret['data']['data']['password']

db_connection = connect(host="db.example.com", password=DATABASE_PASSWORD)
```

</CodeBlockConfig>

Refactoring from hardcoded secrets to runtime Vault retrieval ensures credentials never appear in source code or version control history. The application authenticates to Vault using AppRole and retrieves the current secret value on startup.

Several options exist to retrieve a secret from Vault and you may use one or more methods during the remediation process. Each method has unique advantages and disadvantages. You must weigh the impact of each option against any business or regulatory requirements.

For native integration, you need to refactor your application or service to integrate your application directly with Vault using the secrets engine for the type of secrets you need. This may be your best approach if you maintain consistent development practices across your application teams, such as the use of standardized frameworks like Spring Boot, or retrieve all application configurations from a configuration server.

- Use the Vault Secrets Operator for Kubernetes workloads or Vault secret sync to copy the secrets from Vault to your platform (for example, AWS, Azure, or GCP) built-in secrets management solution. Once you can retrieve the secret from the built-in secrets management solution, update the source code to reference the secret as required by your platform.
- Use the Vault Agent to write the secret to a secure location such as an environment variable. Then, update the source code to reference the environment variable. This option introduces the least amount of friction, and is a good first step to quickly remove the secret from your source code before refactoring the code to use the Vault Secrets Operator, Vault SDK or API.
- Update your application using the Vault SDK, or your programming language's native API/secrets management library. This is the most secure option, but may require significant development effort. Refactoring a legacy application may not be possible. In that scenario, consider the other methods described.

Once you update the data source to retrieve the secret from Vault, you can rotate the secret and securely store it in Vault.

## HashiCorp resources

Detection and incident management:

- Set up [ticket integration for HCP Vault Radar](/hcp/tutorials/get-started-hcp-vault-radar/vault-radar-ticketing-setup) to automate incident tracking
- Set up [alert integration for HCP Vault Radar](/hcp/tutorials/get-started-hcp-vault-radar/vault-radar-alert-setup) for real-time notifications

Vault integration methods:

- Read the [Vault developer quick start](/vault/docs/get-started/developer-qs) for application integration
- Use the [Vault Secrets Operator](/vault/docs/deploy/kubernetes/vso) for Kubernetes workloads
- Use [Vault Enterprise secret sync](/vault/docs/sync) to copy secrets to external systems
- Use the [Vault Agent](/vault/docs/agent-and-proxy) for automated secret retrieval

API and SDK references:

- Read the [Vault API documentation](/vault/api-docs) for programmatic access

### External resources

- [NIST Computer Security Resource Center Incident Response](https://csrc.nist.gov/projects/incident-response)
- [NIST SP 800-61: Computer Security Incident Handling Guide](https://nvlpubs.nist.gov/nistpubs/specialpublications/nist.sp.800-61r2.pdf)
- [PagerDuty incident response](https://response.pagerduty.com/)

## Next steps

In this section of Managing leaked secrets, you learned how to remediate leaked secrets following NIST incident response framework, remove secrets from documentation and source code, and implement secure credential retrieval methods. Remediating leaked secrets is part of the [Secure systems pillar](/well-architected-framework/secure-systems).

After remediating leaked secrets, implement prevention strategies to reduce future incidents:

- [Prevent leaked secrets with access controls](/well-architected-framework/secure-systems/secrets/manage-leaked-secrets/prevent-leaked-secrets-access-controls) - Limit who can access secrets through separation of duties, least privilege, SSO, and zero trust access
- [Prevent leaked secrets with credential management](/well-architected-framework/secure-systems/secrets/manage-leaked-secrets/prevent-leaked-secrets-credential-management) - Eliminate static credentials through dynamic secrets and centralized management

To learn more about the complete secret management strategy, return to the [Manage leaked secrets overview](/well-architected-framework/secure-systems/secrets/manage-leaked-secrets).