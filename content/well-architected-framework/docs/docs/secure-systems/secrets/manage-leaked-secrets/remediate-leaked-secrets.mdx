---
page_title: Remediate leaked secrets
description: Remediate leaked secrets in documentation and code following NIST incident response guidelines for secure rotation and recovery strategies.
---

# Remediate leaked secrets

Once you detect a leaked secret, immediate remediation is critical—attackers typically exploit exposed credentials within 24-48 hours, and breach notification regulations impose strict timelines (GDPR: 72 hours, HIPAA: 60 days). The remediation process involves forming an incident response team, following NIST guidelines, and systematically removing secrets from all locations including version control, documentation, and backups.

If you have not already done so, form an incident response team that includes technical representatives from the security, operations, and development teams, as well as business and legal representatives.

The remediation process varies based on the following factors:

- The type of system the leaked secret gives access to
- The type of data available in that system
- Whether regulations require you to report the incident to a government or industry regulator

Your remediation process should include communication with your stakeholders, both internal (such as development teams) and external (such as customers), to ensure they stay informed of any actions they may need to take.

## Why remediate leaked secrets immediately

**Exposed secrets let attackers gain unauthorized access within hours:** Once attackers discover leaked credentials, they typically exploit them within 24-48 hours. Delayed remediation allows attackers to establish persistence, exfiltrate data, or create backdoor access that remains even after you rotate the original secret.

**Breach notification timelines create legal liability:** Regulations like GDPR (72 hours), HIPAA (60 days), and state breach notification laws impose strict reporting deadlines. Organizations that fail to detect and remediate breaches promptly face significant fines and mandatory public disclosure.

**Incomplete remediation lets attackers re-compromise systems:** Simply rotating a leaked secret without removing it from all locations allows attackers to re-compromise systems. Secrets remain in Git history, backups, logs, and documentation unless you systematically remove them from every location.

**Post-breach costs exceed prevention by 10x:** The average data breach costs $4.45 million, with incident response, forensics, legal fees, and customer notification consuming significant resources. Organizations that remediate quickly limit exposure and reduce total breach costs.

Systematic remediation following NIST incident response guidelines—containment, eradication, recovery, and post-incident review—minimizes business impact and prevents repeat incidents.

## Follow the NIST incident response framework

The National Institute of Standards and Technology (NIST) is a helpful resource for defining requirements for incident response. [NIST SP 800-61: Computer Security Incident Handling Guide](https://nvlpubs.nist.gov/nistpubs/specialpublications/nist.sp.800-61r2.pdf) identifies the following four stages of incident response:

1. **Preparation:** Ensure you have the right tools and processes in place to identify, manage, and remediate incidents.
1. **Detection and analysis:** Identify the incident, and analyze the impact of the incident.
1. **Containment, eradication, and recovery:** Contain the incident, remove the cause of the incident, and recover from the incident.
1. **Post-incident activity:** Review the incident, and update your processes to prevent similar incidents in the future.

## Remove leaked secrets from documentation

If you identify a leaked secret in documentation, first identify what teams, workflows, or applications depend on this secret. A common practice is to document requirements in a configuration management database (CMDB). Similarly, if you are using Terraform to manage your Vault policies, you can cross-reference the policies to determine what teams or applications are using the secret.

If the processes using the secret already retrieve the secret from Vault, complete the following steps:

- Rotate or change the secret
- Remove the plaintext secret from the documentation
- Update the secret value in Vault

Any process retrieving the secret receives the updated secret value from Vault.

The following example shows how to rotate a leaked database password in HashiCorp Vault:

<CodeBlockConfig hideClipboard>

```bash
# Generate new secret value
NEW_SECRET=$(openssl rand -base64 32)

# Update secret in Vault
vault kv put secret/app/database password="$NEW_SECRET"

# Verify rotation
vault kv get secret/app/database
```

</CodeBlockConfig>

The rotation workflow updates a leaked database password in Vault's key-value store. Applications configured to read from Vault automatically receive the updated credential without code changes, eliminating downtime during rotation.

This three-step process generates a cryptographically secure random password, stores it in Vault at the configured path, and verifies the update succeeded. Applications using Vault's KV v2 secrets engine retrieve the new password on their next request or connection retry, making rotation seamless for workloads that don't cache credentials. Run this rotation immediately upon detecting a leaked secret to revoke attacker access.

## Remediate secrets exposed in source code

When you identify a leaked secret in source code, the process is more involved and may require involving other teams.

If the application or workflow built from the source code requires access to this secret, you must update the source code to reference it in a secure manner.

The following example shows how to refactor application code from hardcoded secrets to runtime Vault retrieval:

<CodeBlockConfig hideClipboard>

```python
# Before: Secret hardcoded in source code
DATABASE_PASSWORD = "leaked-password-123"
db_connection = connect(host="db.example.com", password=DATABASE_PASSWORD)

# After: Retrieve secret from Vault at runtime
import hvac

client = hvac.Client(url='http://vault:8200')
client.token = client.auth.approle.login(role_id=ROLE_ID, secret_id=SECRET_ID)['auth']['client_token']

secret = client.secrets.kv.v2.read_secret_version(path='app/database')
DATABASE_PASSWORD = secret['data']['data']['password']

db_connection = connect(host="db.example.com", password=DATABASE_PASSWORD)
```

</CodeBlockConfig>

Refactoring from hardcoded secrets to runtime Vault retrieval ensures credentials never appear in source code or version control history. The application authenticates to Vault using AppRole and retrieves the current secret value on startup.

After this refactoring, commit the updated code and rotate the database password in Vault. The hardcoded credential `leaked-password-123` becomes invalid, preventing attackers from using the exposed value. The AppRole credentials (`ROLE_ID` and `SECRET_ID`) should be injected via environment variables or a secure bootstrap process—never commit them to source control. This pattern works for any secret type: API keys, database passwords, encryption keys, or service account credentials.

Several integration methods exist for retrieving secrets from Vault during remediation. Each method has unique advantages and trade-offs based on your application architecture and development practices:

- **Native Vault integration:** Refactor applications to integrate directly with Vault using secrets engines. Best for teams with standardized frameworks like Spring Boot or centralized configuration servers.

- **Vault Secrets Operator or secret sync:** Use Vault Secrets Operator for Kubernetes workloads or Vault secret sync to copy secrets to platform-native secret managers (AWS Secrets Manager, Azure Key Vault, GCP Secret Manager). Update source code to reference the platform's secret management API.

- **Vault Agent:** Use Vault Agent to write secrets to environment variables or files. Introduces minimal code changes, making it ideal for quick remediation before full refactoring.

- **Vault SDK or API:** Update applications using the Vault SDK or programming language's native API. Most secure option but requires significant development effort. May not be feasible for legacy applications.

Choose your remediation approach based on application constraints:

- **Use native Vault integration** when teams use standardized frameworks and can refactor applications within days.
- **Use Vault Secrets Operator** when workloads run on Kubernetes and need cloud-native secret injection.
- **Use Vault Agent** when you need immediate remediation with minimal code changes before full refactoring.
- **Use Vault SDK/API** when maximum security is required and development resources are available for comprehensive refactoring.

For urgent remediation, start with Vault Agent to quickly remove hardcoded secrets, then plan migration to native integration or Secrets Operator for long-term security.

Once you update the data source to retrieve the secret from Vault, you can rotate the secret and securely store it in Vault.

## HashiCorp resources

The following resources help you implement the remediation strategies described in this guide.

**Related WAF guidance:**

- [Detect leaked secrets](/well-architected-framework/secure-systems/secrets/manage-leaked-secrets/detect-leaked-secrets) for automated scanning and monitoring
- [Prevent leaked secrets with access controls](/well-architected-framework/secure-systems/secrets/manage-leaked-secrets/prevent-leaked-secrets-access-controls) for defense-in-depth prevention
- [Prevent leaked secrets with credential management](/well-architected-framework/secure-systems/secrets/manage-leaked-secrets/prevent-leaked-secrets-credential-management) for eliminating static credentials

**Get started with secret rotation and remediation:**

- Learn [Vault foundations](/vault/tutorials/get-started) for core secrets management concepts
- Follow the [Vault quickstart for developers](/vault/docs/get-started/developer-qs) for application integration patterns
- Learn how to [rotate static secrets in Vault](/vault/tutorials/secrets-management) for manual rotation workflows

**Detection and incident management:**

- Set up [ticket integration for HCP Vault Radar](/hcp/tutorials/get-started-hcp-vault-radar/vault-radar-ticketing-setup) to automate incident tracking
- Set up [alert integration for HCP Vault Radar](/hcp/tutorials/get-started-hcp-vault-radar/vault-radar-alert-setup) for real-time notifications

**Vault integration methods:**

- Read the [Vault developer quick start](/vault/docs/get-started/developer-qs) for application integration
- Use the [Vault Secrets Operator](/vault/docs/deploy/kubernetes/vso) for Kubernetes workloads
- Use [Vault Enterprise secret sync](/vault/docs/sync) to copy secrets to external systems
- Use the [Vault Agent](/vault/docs/agent-and-proxy) for automated secret retrieval

**API and SDK references:**

- Read the [Vault API documentation](/vault/api-docs) for programmatic access
- Explore [Vault client libraries](/vault/docs/get-started/developer-qs#vault-clients) for language-specific SDKs

### External resources

- [NIST Computer Security Resource Center Incident Response](https://csrc.nist.gov/projects/incident-response)
- [NIST SP 800-61: Computer Security Incident Handling Guide](https://nvlpubs.nist.gov/nistpubs/specialpublications/nist.sp.800-61r2.pdf)
- [PagerDuty incident response](https://response.pagerduty.com/)
- [GitHub: Removing sensitive data from a repository](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/removing-sensitive-data-from-a-repository) for Git history cleanup
- [BFG Repo-Cleaner](https://rtyley.github.io/bfg-repo-cleaner/) for removing secrets from Git history

## Next steps

In this section of Managing leaked secrets, you learned how to remediate leaked secrets following NIST incident response framework, remove secrets from documentation and source code, and implement secure credential retrieval methods. Remediating leaked secrets is part of the [Secure systems pillar](/well-architected-framework/secure-systems).

After remediating leaked secrets, implement prevention strategies to reduce future incidents:

- [Prevent leaked secrets with access controls](/well-architected-framework/secure-systems/secrets/manage-leaked-secrets/prevent-leaked-secrets-access-controls) - Limit who can access secrets through separation of duties, least privilege, SSO, and zero trust access
- [Prevent leaked secrets with credential management](/well-architected-framework/secure-systems/secrets/manage-leaked-secrets/prevent-leaked-secrets-credential-management) - Eliminate static credentials through dynamic secrets and centralized management

To learn more about the complete secret management strategy, return to the [Manage leaked secrets overview](/well-architected-framework/secure-systems/secrets/manage-leaked-secrets).