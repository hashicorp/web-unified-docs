---
page_title: Prevent leaked secrets with credential management
description: Eliminate static credentials through dynamic secrets, workload identity federation, and centralized secret management platforms like HashiCorp Vault.
---

# Prevent leaked secrets with credential management

Organizations face constant risk from leaked secrets and exposed credentials. Credential management strategies eliminate static, long-lived secrets by replacing them with dynamic credentials and storing all secrets in centralized platforms with strong access controls.

Prevent secret leaks with the following credential management strategies:

- **Dynamic credentials:** Use short-lived, automatically rotating credentials
- **Workload identity federation:** Eliminate static service account credentials
- **Centralized secret management:** Store and retrieve secrets from a secrets management platform

## Why use dynamic credentials and centralized management

**Static credentials persist in version control:** Long-lived API keys, database passwords, and service account credentials often end up committed to Git repositories, configuration files, and CI/CD systems. Once committed, these secrets remain accessible even after rotation.

**Manual credential rotation fails at scale:** Organizations managing hundreds of applications and services cannot reliably rotate static credentials manually. Forgotten credentials remain active for months or years, expanding the window of exposure if leaked.

**Secret sprawl creates blind spots:** When secrets exist in multiple locations—environment variables, configuration management systems, CI/CD platforms, and developer workstations—security teams lose visibility into what secrets exist and where they're used.

**Service account credentials live forever:** Traditional approaches provision long-lived service accounts for application authentication. These credentials rarely rotate and provide permanent access if compromised, making them high-value targets for attackers.

Implementing credential management strategies—dynamic credentials with workload identity federation and centralized secret storage—eliminates long-lived static secrets and provides centralized visibility and control over all organizational credentials.

## Use dynamic credentials

Dynamic credentials are short-lived credentials generated on demand and valid for a limited time. Dynamic credentials are useful in scenarios where SSO integration is not available. Because these credentials are valid for a limited time, the risk of exposing the secret is reduced.

HashiCorp Vault generates dynamic credentials for a variety of systems, including AWS, Azure, GCP, HCP Terraform, and several database platforms. When your application needs to access a cloud service or database, Vault generates credentials with a specific time-to-live (TTL). When the TTL expires, Vault automatically revokes the credentials.

Dynamic credentials provide the following benefits:

- Credentials exist only for the duration of a specific task or session
- Automatic revocation eliminates the need for manual rotation
- Each workload receives unique credentials, improving audit trails
- Compromised credentials have limited validity, reducing breach impact
- No long-lived credentials to store in code or configuration

You can configure your application to request dynamic credentials from Vault before connecting to a cloud service provider, or backend database. You can also use the HCP Terraform secrets engine to generate dynamic credentials for different Terraform providers. This allows Terraform to provision the defined resources without needing to store static credentials.

### Workload identity federation

Workload identity federation (WIF) removes static credentials by creating trust relationships between systems. For example, GitHub Actions can authenticate to AWS without storing any AWS credentials. Once you complete the WIF configuration, a service like Terraform or Vault creates dynamic credentials in the target platform. Compare this to conventional methods where you might provision a long lived service account with a key or password. These accounts still need to managed, and rotated. With WIF, there is a trust between the systems so there is no risk to the service account secret being leaked. The service that provisions the dynamic credential revokes it when the workflow is complete or TTL expires.

Where SSO and WIF diverge is that WIF uses the trust relationship to provision temporary, dynamic credentials. These credentials have a short TTL, so there is a limited risk if they become exposed. Credentials are managed by the configured services, so there is no need to revoke, renew, or replace the credentials.

Vault Enterprise supports WIF integration with AWS, Azure, and GCP. Using WIF, you can configure the cloud provider auth method, or secrets engine without static service accounts.

Workload identity federation follows the following workflow:

1. Your CI/CD platform or orchestrator issues a signed identity token
1. The workload presents this token to Vault for authentication
1. Vault validates the token against configured trust policies
1. Vault issues a short-lived token or credential for the requested resource
1. The workload uses the credential for its task
1. The credential expires automatically after the configured TTL

Workload identity federation eliminates the need to store any long-lived credentials in your CI/CD system or application configuration.

## Centralize secret management

Once you have a process in place to identify leaked secrets, you should verify whether the secret is in use and ensure that you are managing it effectively moving forward. These two steps are important to manage properly so you do not inadvertently rotate a secret used by another system and bring those services down.

When you identify a leaked secret, your solution should determine if the secret is in use and whether it's in your secret manager. Determining whether it's in use and where it's located helps in the next phase of the process — remediation. If the leaked secret is not stored in your secret manager, add the secret before you begin the remediation process.

Another important feature for centralizing secrets management is the ability to copy or sync secrets to other systems. The ability to sync secrets helps with workloads or platforms that may be isolated, or systems that you cannot update to support a centralized secrets management solution.

<VideoEmbed url="https://www.youtube.com/watch?v=XcW73DF0F9w" />

HashiCorp Vault is a centralized secrets management and security solution with several deployment options. If you are new to secrets management, you can start by storing secrets as key-value pairs, and update your workflows to read the secret directly from Vault. As your secrets management process matures, you can use short-lived, dynamic credentials which are valid for a specified period of time. This further limits the effect if you do leak a secret because Vault will automatically revoke it after the specified time, or you can manually revoke it and request new credentials.

You can prevent storing secrets in your code by securing your secrets in a centralized secrets management system such as Vault, and then referencing these secrets in your code. The following Python example shows how to use Vault client libraries inside your application code to store and retrieve secret values.

<CodeBlockConfig hideClipboard>

```python
read_response = client.secrets.kv.read_secret_version(path='my-secret-password')
password = read_response['data']['data']['password']
```

</CodeBlockConfig>

The code retrieves a secret from Vault's key-value store at runtime rather than embedding the password directly in the application. This pattern ensures secrets remain centralized and encrypted at rest, with all access logged for audit purposes.

### Benefits of centralized secret management

Centralized secret management provides the following capabilities:

- **Single source of truth:** All secrets stored in one auditable location
- **Encryption at rest and in transit:** Secrets protected throughout their lifecycle
- **Fine-grained access control:** Policies determine which applications access which secrets
- **Complete audit trails:** All secret access logged with identity and timestamp
- **Automated rotation:** Secrets rotate on schedule without application changes
- **Secret versioning:** Previous secret versions retained for rollback scenarios
- **Synchronization capabilities:** Secrets synced to external systems when needed

### Migration path to centralized management

Organizations typically migrate to centralized secret management in phases:

1. **Discovery:** Inventory existing secrets across all systems
2. **Centralization:** Migrate static secrets to Vault key-value storage
3. **Application integration:** Update applications to read from Vault
4. **Dynamic credentials:** Replace static secrets with dynamically generated credentials
5. **Workload identity:** Eliminate bootstrap credentials through WIF

The phased migration approach allows you to gain value quickly while working toward the ideal state of zero static credentials.

## HashiCorp resources

Get started with Vault:

- Learn [Vault foundations](/vault/tutorials/get-started) for core concepts
- Get started with [HCP Vault Dedicated quickstart](/vault/tutorials/get-started-hcp-vault-dedicated) for managed deployment
- [Sign up for HCP Vault Dedicated](https://portal.cloud.hashicorp.com/sign-in)

Vault dynamic credentials:

- Learn about [Vault dynamic database credential management](/vault/tutorials/db-credentials) for automated rotation
- Learn how to [generate cloud provider credentials with Vault](/vault/tutorials/secrets-management/azure-secrets) for AWS, Azure, and GCP
- Learn how to [manage credentials for HCP Terraform with Vault](/vault/tutorials/secrets-management/terraform-secrets-engine) for infrastructure provisioning
- Use [HCP Terraform dynamic provider credentials](/terraform/cloud-docs/workspaces/dynamic-provider-credentials) for secure authentication
- Learn how to [enable self-service workflows with Vault-backed dynamic credentials](/terraform/tutorials/cloud/dynamic-credentials-no-code) for no-code provisioning
- Learn how to [inject secrets into Terraform using the Vault provider](/terraform/tutorials/secrets/secrets-vault) for runtime retrieval

Vault workload identity federation:

- Learn how to [manage federated workload identities with Vault](/vault/tutorials/enterprise/plugin-workoad-identity-federation) for trust-based authentication
- Follow the [Vault Enterprise workload identity federation tutorial](/vault/tutorials/enterprise/plugin-workoad-identity-federation) for implementation

### External resources

- Review the [OWASP Secrets Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html)

## Next steps

In this section of Managing leaked secrets, you learned how to prevent leaked secrets through credential management including dynamic credentials, workload identity federation, and centralized secret storage platforms like HashiCorp Vault. Preventing leaked secrets with credential management is part of the [Secure systems pillar](/well-architected-framework/secure-systems).

Continue to the following document to complete your prevention strategy:

- [Prevent leaked secrets with access controls](/well-architected-framework/secure-systems/secrets/manage-leaked-secrets/prevent-leaked-secrets-access-controls) - Limit who can access secrets through separation of duties, least privilege, SSO, and zero trust access

To learn more about the complete secret management strategy, return to the [Manage leaked secrets overview](/well-architected-framework/secure-systems/secrets/manage-leaked-secrets).
