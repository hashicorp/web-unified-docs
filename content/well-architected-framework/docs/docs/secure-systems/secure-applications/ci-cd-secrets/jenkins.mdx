---
page_title: Jenkins
description: Learn how to integrate Jenkins CI/CD pipelines with HashiCorp Vault for centralized secrets management, dynamic credential generation, and audit logging.
---

# Jenkins

Jenkins uses plugins to integrate with third-party tools. Traditionally, you would manage Jenkins secrets for pipelines with
[Jenkins credential management](https://docs.cloudbees.com/docs/cloudbees-ci/latest/cloud-secure-guide/injecting-secrets)
in the Jenkins Controller. The credential management approach binds all secrets to environment variables, and masks these variables when they appear in pipeline logs. However, the conventional approach can lead to secret sprawl with external system credentials (like tokens, database credentials, and other pipeline secrets) duplicated in Jenkins. The Jenkins Controller also relies on the Jenkins user database for role-based access control (RBAC) rather than implementing more secure granular access control lists (ACLs) based on credential paths.

## Why

Managing secrets in Jenkins pipelines presents several challenges:

**Secret sprawl across jobs and credentials:** Teams often duplicate secrets across multiple Jenkins jobs, folders, and credential stores, making rotation difficult and increasing the risk of exposure if a single Jenkins controller is compromised.

**Limited native credential management:** Jenkins credential management provides basic secret storage with log masking, but lacks advanced features like automatic rotation, dynamic secret generation, and centralized policy management across multiple Jenkins controllers.

**Compliance and audit requirements:** Organizations need detailed audit trails showing which pipelines accessed which secrets and when, but Jenkins native logging may not provide the granularity required for regulatory compliance frameworks like SOC 2, PCI DSS, and HIPAA.

**No dynamic credential support:** Static secrets stored in Jenkins credentials remain valid indefinitely, creating a larger attack surface compared to short-lived dynamic credentials that expire automatically.

Integrating Vault with Jenkins addresses these challenges by centralizing secrets management, enabling dynamic secret generation, providing comprehensive audit logs, and supporting automatic credential rotation.

## Prerequisites

Before integrating Jenkins with Vault, you need the following:

- A Vault instance accessible from your Jenkins agents over the network
- Jenkins admin access to install plugins and configure credentials
- A Vault authentication method configured (AppRole or JWT recommended for CI/CD)
- Vault policies that grant Jenkins the necessary read permissions for your secrets
- For production: TLS encryption between Jenkins and Vault

Refer to [Available authentication methods](/vault/docs/auth) for Vault auth method options.

## Use a best practice approach

A more secure method to inject and use credentials during pipeline runs is to use API integration with Vault for each pipeline step. When you use this approach in your pipelines, you gain the following:

1. Vault manages authorization for stored secrets based on externally authenticated identities.
1. The Jenkins Credentials Plugin secures the Vault authentication process.
1. Vault auth methods (like AppRole or JWT) benefit from the Credentials Management plugin's binding capabilities.
1. Authenticated pipelines can make API calls to Vault, and retrieve just the necessary secrets for completing specific jobs.

The Vault API integration provides stronger security controls, while reducing secret sprawl throughout your organization.

## Use the Jenkins Vault plugin and other methods

Depending on your security requirements for protecting secrets in Jenkins pipeline logs, you can choose from the following approaches to authenticate to Vault:

### Choose an approach

Use the **Jenkins Vault plugin** when you need automatic log masking and a declarative pipeline syntax with minimal configuration overhead.

Use the **CloudBees CI Vault plugin** when you're running CloudBees CI and need centralized credential lifecycle management with both static and dynamic secrets.

Use **credentials binding with REST API** when you need maximum flexibility for complex secret retrieval patterns involving multiple credential types, structured organization, or Vault Enterprise namespaces.

Use **Vault Agent sidecar** when you want to eliminate Jenkins plugin dependencies entirely, especially with ephemeral agents or containerized workloads. Note that this approach requires additional masking configuration to prevent secrets from appearing in logs.

### Jenkins Vault plugin

The Jenkins Vault plugin serves as an authentication helper, and provides secret binding during pipeline execution. The Jenkins Vault plugin offers the following advantages:

- Automatically masks any secret retrieved from Vault in the pipeline logs
- Provides a streamlined and declarative syntax for secret retrieval
- Seamlessly integrates with Jenkins credentials management

### CloudBees CI Vault plugin

CloudBees CI provides a shared, centrally managed, self-service experience for development teams running Jenkins either on-premise or in the cloud. You can use the [CloudBees HashiCorp Vault Plugin](https://docs.cloudbees.com/plugins/ci/cloudbees-hashicorp-vault) to manage the lifecycle of your CloudBees controller static or dynamic Vault credentials. Learn how to install and configure the HashiCorp Vault plugin with the Jenkins CLI or Plugin Manager in the [CloudBees HashiCorp Vault Plugin documentation](https://docs.cloudbees.com/docs/cloudbees-ci/latest/secure/hashicorp-vault-plugin).

The following examples demonstrate how to use secrets in CloudBees CI pipelines.

Add a secret for the username and password auth method:


```groovy
withCredentials([usernamePassword(credentialsId: 'vault-creds', passwordVariable: 'PASS', usernameVariable: 'USER')]) {
    sh 'echo USER=$USER'
    sh 'echo PASS=$PASS'
}
```

The `withCredentials` block retrieves username and password credentials from Vault through the CloudBees CI Vault plugin, and binds them to environment variables that the pipeline can use to authenticate to downstream services.

Use a static secret from a Vault key/value secrets engine:

```groovy
withCredentials([string(credentialsId: 'vault-creds', variable: 'TOKEN')]) {
    sh 'echo TOKEN=$TOKEN'
}
```

The string credential binding retrieves a single static secret from the Vault KV secrets engine and stores it in the `TOKEN` environment variable for use within the pipeline step.

Consult the [CloudBees HashiCorp Vault Plugin documentation](https://docs.cloudbees.com/docs/cloudbees-ci/latest/secure/hashicorp-vault-plugin) for more details.

### Credentials binding with REST API

You can use Jenkins credentials binding to securely manage environment variables, like `VAULT_TOKEN`, `VAULT_ADDR`, and `VAULT_NAMESPACE`. The credentials binding solution provides the following features in your pipelines:

- Masks environment variables in the pipeline logs
- Allows you to make REST API calls to Vault with the bound credentials
- Offers more flexibility for complex secret retrieval patterns where an application might need several types of credentials from different paths, and which use function abstraction, structured secret organization, secret composition, and Enterprise namespaces.

### Vault Agent sidecar

When you implement Vault Agent directly on Jenkins Agents, you create a powerful pattern for accessing secrets across pipelines. Using this approach provides the following advantages:

- Remove the need for extra Jenkins plugins
- Works well with ephemeral agents using a Vault Agent sidecar configuration
- Simplifies secret retrieval for containerized workloads

<Note>

Secrets retrieved from Vault with this method can appear in pipeline logs without adding specific masking configuration.

</Note>

The approach that best suits your environment depends on your organization's security requirements, infrastructure configuration, and operational preferences.

## Use Vault dynamic secrets in Jenkins

All four Jenkins-Vault integration approaches support both static and dynamic secrets from Vault. Dynamic secrets are generated on-demand and automatically expire, providing stronger security than long-lived static credentials.

You can use the Jenkins Vault plugin to retrieve and protect dynamic Vault secrets in the pipeline logs.
These secrets include for example: Terraform API tokens, GCP keys, and database credentials. You can do this in the
[pipeline as code definition](https://www.jenkins.io/doc/book/pipeline/syntax/) by specifying the
`engine version 1` specification of the plugin, like in the following example:

```groovy
stage('My Stage') {
  steps {
    withVault(
      configuration: [
        vaultCredentialId: "my-vault-creds",
        vaultUrl: "http://vault:8200"
      ],
      vaultSecrets: [
        [
          path: "terraform/creds/tfe-role",
          engineVersion: 1,
          secretValues: [
            [envVar: "tfe_token", vaultKey: "token"]
          ]
        ]
      ]
    ) {
      sh """
        curl -H "Authorization: Bearer ${env.tfe_token}" \\
          -H "Content-Type: application/vnd.api+json" \\
          -X GET \\
          "https://app.terraform.io/api/v2/workspaces/"
      """
    }
  }
}
```

The pipeline stage uses the Jenkins Vault plugin to retrieve a dynamic Terraform credential from Vault at the `terraform/creds/tfe-role` path. The `withVault` block ensures the short-lived token is automatically revoked after the stage completes, and the `tfe_token` environment variable is masked in pipeline logs.

If you do not use the Jenkins Vault plugin, it is possible to do a REST API call to Vault and mask the
`VAULT_TOKEN` environment variable in the pipeline logs. Masking the
`VAULT_TOKEN` environment variable is possible using the Credentials Management in Jenkins.
You can also use the Vault Agent plugin to manage the token caching, avoiding the usage of any plugin in that case.

An external process executed in the Jenkins Agent, such as an admin pipeline or init process,
can manage the Vault login that retrieves the token value specified in the
`VAULT_TOKEN` environment variable and puts it in a Jenkins credential.

## Verify the integration

After configuring Jenkins to retrieve secrets from Vault, verify the integration works correctly:

1. **Run a test pipeline:** Create a simple pipeline that retrieves a test secret from Vault and uses it in a shell command. Confirm the secret is masked in the pipeline logs.
1. **Check Vault audit logs:** Verify that Vault audit logs show successful authentication from Jenkins and secret reads at the expected paths.
1. **Test secret rotation:** If using dynamic secrets, verify that Vault generates new credentials on each pipeline run and that old credentials are revoked after use.
1. **Validate least-privilege access:** Confirm that Jenkins can only access secrets permitted by its Vault policy and cannot read secrets outside its scope.

## Production readiness

Before deploying your Vault integration to production, verify the following:

- **High availability:** Use a Vault cluster with multiple nodes or [HCP Vault Dedicated](/hcp/docs/vault) for automatic HA
- **Monitoring:** Configure [Vault telemetry](/vault/docs/internals/telemetry/enable-telemetry) to alert on seal status, authentication failures, and secret access anomalies
- **Audit logging:** Enable at least one [Vault audit device](/vault/docs/audit) for compliance and security investigations
- **Secret rotation:** Implement automated rotation for static secrets and appropriate TTLs for dynamic secrets
- **Disaster recovery:** Document and test your Vault recovery procedures, including unseal processes and backup restoration
- **Network security:** Ensure TLS encryption for all Vault communication and restrict network access to authorized CI/CD runners

Review the [Vault production hardening guide](/vault/tutorials/vault/production-hardening) for comprehensive production deployment recommendations.

## HashiCorp resources

CI/CD secrets overview:

- [CI/CD secrets overview](/well-architected-framework/secure-systems/secure-applications/ci-cd-secrets)
- [Dynamic and static secrets in CI/CD](/well-architected-framework/secure-systems/secure-applications/ci-cd-secrets/dynamic-and-static-secrets)
- [CI/CD secrets anti-patterns](/well-architected-framework/secure-systems/secure-applications/ci-cd-secrets/anti-patterns)

Vault authentication for CI/CD:

- Read the [Vault authentication methods documentation](/vault/docs/auth) for an overview of available auth methods
- Learn about the [AppRole auth method](/vault/docs/auth/approle) for machine-to-machine authentication in pipelines
- Read the [JWT/OIDC auth method documentation](/vault/docs/auth/jwt) for token-based pipeline authentication

Vault secrets and dynamic credentials:

- Understand [dynamic and static secrets](/vault/tutorials/get-started/understand-static-dynamic-secrets) to choose the right approach for your pipelines
- Read the [KV secrets engine documentation](/vault/docs/secrets/kv) for static secret storage

Vault Agent:

- Get started with the [Vault Agent quick start tutorial](/vault/tutorials/vault-agent/agent-quick-start) for sidecar-based secret retrieval

### External resources

- Read the [CloudBees HashiCorp Vault Plugin documentation](https://docs.cloudbees.com/docs/cloudbees-ci/latest/secure/hashicorp-vault-plugin) for installation and configuration guidance
- Watch [Using HashiCorp Vault With CloudBees CI](https://www.youtube.com/watch?v=05Rw1Qkjz4c) for a video demonstration of the Vault plugin integration
- Review the [Jenkins on Kubernetes with Vault code examples](https://github.com/dcanadillas/hashi-cicd?tab=readme-ov-file) for working pipeline implementations

## Next steps

In this section of [managing CI/CD secrets](/well-architected-framework/secure-systems/secure-applications/ci-cd-secrets), you learned about Jenkins and Vault integration. Jenkins and Vault integration is part of the [Secure systems pillar](/well-architected-framework/secure-systems).