---
page_title: GitLab
description: Learn how to integrate GitLab with HashiCorp Vault for secure secrets management.
---

# GitLab

GitLab uses a JSON Web Token (JWT) to authenticate with Vault to securely access secrets for CI/CD pipelines. Once authenticated, GitLab can pull static secrets from the KV secrets engine, or dynamic secrets from engines such as the [AWS secrets engine](/vault/docs/secrets/aws).

## Why

Managing secrets in GitLab pipelines presents several challenges:

**Secret sprawl across projects:** Teams often duplicate secrets across multiple GitLab projects and environments, making rotation difficult and increasing the risk of exposure if a single project is compromised.

**Limited CI/CD variable protection:** GitLab's built-in CI/CD variables provide basic secret storage, but lack advanced features like automatic rotation, dynamic secret generation, and centralized policy management across multiple GitLab instances.

**Compliance and audit requirements:** Organizations need detailed audit trails showing which pipelines accessed which secrets and when, but GitLab's native logging may not provide the granularity required for regulatory compliance.

**No dynamic credential support:** Static secrets stored in GitLab variables remain valid indefinitely, creating a larger attack surface compared to short-lived dynamic credentials that expire automatically.

Integrating Vault with GitLab addresses these challenges by centralizing secrets management, enabling dynamic secret generation, providing comprehensive audit logs, and supporting automatic credential rotation.

## Prerequisites

Before integrating GitLab with Vault, you need the following:

- A Vault instance accessible from GitLab runners over the network (or use HCP Vault)
- GitLab project with maintainer or owner access to configure CI/CD settings
- A Vault authentication method configured (JWT/OIDC recommended for GitLab)
- Vault policies that grant GitLab the necessary read permissions for your secrets
- For production: TLS encryption between GitLab and Vault

Refer to [Available authentication methods](/vault/docs/auth) for Vault auth method options.

Follow the guidance in [Use HashiCorp Vault secrets in GitLab CI/CD](https://docs.gitlab.com/ci/secrets/hashicorp_vault/) to configure your GitLab pipeline to establish authentication and use secrets in Vault. Review the [Using external secrets in CI](https://docs.gitlab.com/ci/secrets/#use-vault-secrets-in-a-ci-job) tutorial to learn more about using Vault secrets engines with your GitLab pipelines.

<Tabs>
<Tab heading="GitLab Premium" group="gitlab">

### Static secrets

To use static secrets, reference the [`secrets:vault`](https://docs.gitlab.com/ee/ci/yaml/index.html#secretsvault)
keyword in the secrets portion of your `gitlab-ci.yml` file.

In the following example, the GitLab pipeline automatically authenticates to Vault with an ID Token. The pipeline then uses `secrets:vault` to pull a secret from the Vault K/V secrets engine at the path /ops/production/db, and set the value of the password field as the `DATABASE_PASSWORD` environment variable. Pipeline jobs 
can then use the secret stored in the environment variable to authenticate to the correlating database. Refer to the [Use Vault secrets in a CI job](https://docs.gitlab.com/ee/ci/secrets/index.html#use-vault-secrets-in-a-ci-job) for further documentation.

```yaml
job_with_secrets:
  id_tokens:
    # Automatically authenticate to Vault with GitLab ID token
    VAULT_ID_TOKEN:
      aud: https://vault.example.com
  secrets:
    # Store the secret value in the DATABASE_PASSWORD environment variable
    DATABASE_PASSWORD:
      # Secret path: ops/data/production/db, field: password
      vault: production/db/password@ops
      # Store value directly in the environment variable, not a file
      file: false
```

This configuration automatically authenticates to Vault using GitLab's OIDC ID token, retrieves the database password from Vault's KV secrets engine at the path `ops/data/production/db`, and makes it available as the `DATABASE_PASSWORD` environment variable. GitLab Premium automatically handles the authentication and secret retrieval without requiring additional code.

You can also pull static secrets and set them to environment variables from the CLI with manual authentication as shown in the
[Manual ID Token authentication](https://docs.gitlab.com/ci/secrets/hashicorp_vault/#manual-id-token-authentication) documentation example.

```yaml
manual_authentication:
  variables:
    VAULT_ADDR: http://vault.example.com:8200
  image: vault:latest
  id_tokens:
    VAULT_ID_TOKEN:
      aud: http://vault.example.com
  # Store the secret value in the DATABASE_PASSWORD environment variable
  script:
    - export DATABASE_PASSWORD="$(vault kv get -field=password secret/myproject/example/db)"
```

This manual authentication approach uses the Vault CLI to authenticate with GitLab's OIDC ID token and retrieve secrets. This method provides more flexibility for complex secret retrieval patterns and works with GitLab Premium when you need programmatic access to Vault.

The following diagram shows the steps a GitLab CI/CD pipeline takes to retrieve a secret from Vault.
![GitLab Vault workflow](/img/well-architected-framework/gitlab-vault-workflow.png)

### Dynamic secrets

GitLab users are also able to take advantage of Vault dynamic secrets engines. Once you set up JWT authentication to
Vault as described above, you can enable a dynamic secrets engine such as
[AWS secrets engine](/vault/docs/secrets/aws) in Vault.
The AWS secrets engine lets GitLab CI/CD jobs request short-lived dynamic AWS credentials.

The following is an example of using dynamic AWS credentials in a GitLab job.

<Note>

If you're [signing requests to AWS](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_sigv.html), you may need to set `AWS_SESSION_TOKEN` in the following example.

</Note>

```yaml
read_secrets:
  image: hashicorp/vault:latest
  script:
    # jq must be installed
    # set the dynamic aws credentials to AWS_CREDS variable
    - export AWS_CREDS="$(vault read aws/creds/my-role -format=json)"
    # use jq to parse AWS_CREDS and set the AWS access_key to AWS_ACCESS_KEY_ID
    - AWS_ACCESS_KEY_ID=$(echo "${AWS_CREDS}" | jq -r .data.access_key)
    - export AWS_ACCESS_KEY_ID
    # use jq to parse AWS_CREDS and set the AWS secret_key to AWS_SECRET_ACCESS_KEY
    - AWS_SECRET_ACCESS_KEY=$(echo "${AWS_CREDS}" | jq -r .data.secret_key)
    - export AWS_SECRET_ACCESS_KEY
    # uncomment next two lines to use set a session token if required
    #- AWS_SESSION_TOKEN=$(echo "$(AWS_CREDS}" | jq -r .data.security.token)
    #- export AWS_SESSION_TOKEN
```

This example retrieves short-lived AWS credentials from Vault's AWS secrets engine. Vault generates unique credentials for each pipeline run with a configured TTL (for example, 1 hour), and automatically revokes them after expiration. This eliminates the need to manage long-lived AWS access keys and reduces the attack surface.

</Tab>

<Tab heading="GitLab Community Edition" group="gitlab">

GitLab Community Edition users can pull secrets from Vault.

You must manually set the authentication environment variables to do so.

```yaml
read_secrets:
  image: hashicorp/vault:latest
  id_tokens:
    VAULT_AUTH_TOKEN:
      aud: https://gitlab.com
  script:
    - export VAULT_ADDR=http://vault.example.com:8200
    # authenticate and get token. Token expiry time and other properties can be configured
    # when configuring JWT Auth - https://developer.hashicorp.com/vault/api-docs/auth/jwt#parameters-1
    - export VAULT_TOKEN="$(vault write -field=token auth/jwt/login role=myproject-staging jwt=$VAULT_AUTH_TOKEN)"
    # use the VAULT_TOKEN to read the secret and store it in an environment variable
    - export PASSWORD="$(vault kv get -field=password secret/myproject/staging/db)"
```

GitLab Community Edition requires manual authentication using the Vault CLI. This example authenticates to Vault using GitLab's OIDC ID token, retrieves a Vault token with the configured TTL, and uses it to read secrets from the KV secrets engine. Once authenticated, you can pull both static and dynamic secrets through the CLI as covered in the GitLab Premium tab.

</Tab>
</Tabs>

## Verify the integration

After configuring GitLab to retrieve secrets from Vault, verify the integration works correctly:

1. **Run a test pipeline:** Create a simple pipeline that retrieves a test secret from Vault and uses it in a script. Confirm the secret is masked in GitLab pipeline logs.
2. **Check Vault audit logs:** Verify that Vault audit logs show successful authentication from GitLab and secret reads at the expected paths.
3. **Test secret rotation:** If using dynamic secrets, verify that Vault generates new credentials on each pipeline run and that old credentials are revoked after the configured TTL.
4. **Validate least-privilege access:** Confirm that GitLab can only access secrets permitted by its Vault policy and cannot read secrets outside its scope.

## Production readiness

Before deploying your Vault integration to production, verify the following:

- **High availability:** Use a Vault cluster with multiple nodes or [HCP Vault Dedicated](/hcp/docs/vault) for automatic HA
- **Monitoring:** Configure [Vault telemetry](/vault/docs/internals/telemetry/enable-telemetry) to alert on seal status, authentication failures, and secret access anomalies
- **Audit logging:** Enable at least one [Vault audit device](/vault/docs/audit) for compliance and security investigations
- **Secret rotation:** Implement automated rotation for static secrets and appropriate TTLs for dynamic secrets
- **Disaster recovery:** Document and test your Vault recovery procedures, including unseal processes and backup restoration
- **Network security:** Ensure TLS encryption for all Vault communication and restrict network access to authorized CI/CD runners

Review the [Vault production hardening guide](/vault/tutorials/vault/production-hardening) for comprehensive production deployment recommendations.

## HashiCorp resources

CI/CD secrets overview:

- [CI/CD secrets overview](/well-architected-framework/secure-systems/secure-applications/ci-cd-secrets)
- [Dynamic and static secrets in CI/CD](/well-architected-framework/secure-systems/secure-applications/ci-cd-secrets/dynamic-and-static-secrets)
- [CI/CD secrets anti-patterns](/well-architected-framework/secure-systems/secure-applications/ci-cd-secrets/anti-patterns)

Vault authentication for CI/CD:

- Read the [Vault authentication methods documentation](/vault/docs/auth) for an overview of available auth methods
- Learn about [JWT/OIDC auth method](/vault/docs/auth/jwt) for token-based pipeline authentication

Vault secrets and dynamic credentials:

- Learn about [AWS dynamic secrets engine](/vault/docs/secrets/aws) for cloud credentials
- Explore [dynamic secrets for database credential management](/vault/tutorials/db-credentials/database-secrets) for database access
- Complete the [Generate cloud provider credentials with Vault tutorial](/vault/tutorials/secrets-management/azure-secrets) for Azure integration
- Learn how to [manage LDAP credentials with Vault](/vault/tutorials/secrets-management/openldap) for directory services
- Read the [KV secrets engine documentation](/vault/docs/secrets/kv) for static secret storage
- Understand [dynamic and static secrets](/vault/tutorials/get-started/understand-static-dynamic-secrets) to choose the right approach

### External resources

- [Authenticating and reading secrets with HashiCorp Vault](https://docs.gitlab.com/ee/ci/examples/authenticating-with-hashicorp-vault/)

- [Using external secrets in CI](https://docs.gitlab.com/ee/ci/secrets/)

- Guy Barros, a Senior Solutions Engineer at HashiCorp, maintains a [repository](https://github.com/GuyBarros/terraform_vault_gitlab_auth) with Terraform code to automate the JWT auth method integration between HCP Vault Dedicated and GitLab. Barros demonstrates how to use the Terraform code in the [Codify your JWT-OIDC Vault auth method with Terraform](https://www.youtube.com/watch?v=M-Lq7TDV-70) HashiTalks video.

- GitLab Unfiltered - [How to integrate GitLab CI with HashiCorp Vault to retrieve secrets (via JWT or "secrets:")](https://www.youtube.com/watch?v=NsPcl4rqy9A), uses AWS Quick Start to launch [HashiCorp Vault on AWS](https://aws.amazon.com/quickstart/architecture/vault/), and demonstrates how to set up policies, roles, and authentication to Vault.

## Next steps

In this section of [managing CI/CD secrets](/well-architected-framework/secure-systems/secure-applications/ci-cd-secrets), you learned about GitLab and Vault integration. GitLab and Vault integration is part of the [Secure systems pillar](/well-architected-framework/secure-systems).