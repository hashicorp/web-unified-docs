---
page_title: Dynamic and static secrets in CI/CD
description: Learn about dynamic versus static secrets in CI/CD pipelines.
---

# Dynamic and static secrets in CI/CD

You can use both dynamic and static secrets in your CI/CD pipelines, depending on your security requirements and workflow.

## Why

Choosing the right secret type for your CI/CD pipelines affects both security posture and operational complexity:

**Security risks from long-lived credentials:** Static secrets that never expire create a larger attack surface because compromised credentials remain valid indefinitely, giving attackers unlimited time to exploit them and access sensitive systems.

**Operational overhead from manual rotation:** Organizations struggle to rotate static secrets across multiple CI/CD systems, repositories, and environments, leading to outdated credentials remaining in production and creating security vulnerabilities.

**Compliance requirements for credential lifecycle:** Regulatory frameworks like SOC 2, PCI DSS, and HIPAA require demonstrable secrets management controls including automatic expiration, audit logging, and least-privilege accessâ€”all of which are easier to achieve with dynamic secrets.

**Audit and attribution challenges:** Static secrets shared across multiple pipelines and teams make it difficult to attribute actions to specific users or systems, complicating security investigations and compliance audits.

Understanding the differences between dynamic and static secrets helps you choose the right approach for each use case in your CI/CD pipelines.

Static secrets are conventional, long-lived credentials that you manually create and store. Static secrets remain unchanged until explicitly updated or destroyed. In contrast, dynamic secrets are created on-demand when a client requests them. Each client request for dynamic secrets generates a new set of credentials. Dynamic secrets also expire after a specified time.

| Aspect | Dynamic Secrets | Static Secrets |
|--------|----------------|----------------|
| **Creation** | Generated by Vault on-demand | Manually created and stored |
| **Lifecycle** | Automatic expiration/revocation | Manual rotation/revocation |
| **Lifespan** | Short-lived (minutes to hours) | Long-lived (until changed) |
| **Uniqueness** | Unique per request | Shared across users/systems |
| **Auditing** | Detailed per-request tracking | Limited audit capabilities |
| **Risk** | Lower (minimal exposure time) | Higher (persistent credentials) |

You can use HashiCorp Vault to manage both dynamic and static secrets in your CI/CD pipelines. Vault provides a unified interface for managing secrets, enabling you to enforce consistent security policies across your workflows.

## Dynamic secrets

When you request access to a secret, Vault generates a dynamic secret on demand. Dynamic secrets don't exist until a user or system reads them, eliminating the risk of theft or unauthorized use by another client. Vault's built-in revocation mechanisms allow it to revoke dynamic secrets after use, minimizing the lifespan of the secret.

Vault supports a range of [secret engines](/vault/docs/secrets#secrets-engines) that integrate with services like CI/CD tools to generate dynamic credentials as needed. These secrets engines are plugins to external services, such as AWS, Azure, GCP, Kubernetes, databases, and more. After enabling a secrets engine and authenticating Vault to an external resource, users can request credentials from Vault to access the external resource.

Consider a CI/CD pipeline job that requires retrieving an object from Amazon S3. Instead of using hard-coded AWS credentials in code, plaintext files, or CI/CD environment variables, the pipeline can authenticate to Vault using one of the supported
[authentication methods](/vault/docs/auth). Once authenticated, Vault issues temporary credentials to the CI/CD job that automatically expire when the pipeline completes its task. The pipeline task can use these temporary credentials to retrieve the object from S3 securely.

The following are benefits of using dynamic secrets in CI/CD pipelines:

- **Reduce risk**: No long-lived credentials that can become compromised
- **Automatic cleanup**: No manual revocation required
- **Unique tracking**: Each credential tied to specific access request
- **Better auditing**: Clear audit trail of credential usage

### Dynamic secrets example

This example shows a CI/CD pipeline retrieving dynamic AWS credentials from Vault:

```bash
# Authenticate to Vault using CI/CD platform's OIDC token
export VAULT_TOKEN=$(vault write -field=token auth/jwt/login \
  role=ci-cd-role \
  jwt=$CI_JOB_JWT_V2)

# Request dynamic AWS credentials (generated on-demand)
AWS_CREDS=$(vault read -format=json aws/creds/deploy-role)
export AWS_ACCESS_KEY_ID=$(echo $AWS_CREDS | jq -r '.data.access_key')
export AWS_SECRET_ACCESS_KEY=$(echo $AWS_CREDS | jq -r '.data.secret_key')

# Use credentials for deployment
aws s3 cp application.zip s3://deployment-bucket/

# Credentials automatically expire after configured TTL (e.g., 1 hour)
# Vault automatically revokes credentials even if pipeline fails
```

Each pipeline run generates unique AWS credentials that expire after a short TTL, eliminating the need to manage long-lived access keys.

## HashiCorp resources

CI/CD secrets overview:

- [CI/CD secrets overview](/well-architected-framework/secure-systems/secure-applications/ci-cd-secrets)
- [CI/CD secrets anti-patterns](/well-architected-framework/secure-systems/secure-applications/ci-cd-secrets/anti-patterns)

Understanding secrets types:

- Complete the [Understand dynamic secrets tutorial](/vault/tutorials/get-started/understand-static-dynamic-secrets) to learn the differences between secret types
- Read about [secrets engines](/vault/docs/secrets) for an overview of Vault's secrets management capabilities

Dynamic secrets:

- Learn about [database credential rotation](/vault/tutorials/db-credentials) for dynamic database credentials
- Explore [dynamic secrets for AWS authentication](/vault/tutorials/db-credentials/database-secrets) for S3 access
- Use the [SSH secrets engine for one-time passwords](/vault/tutorials/secrets-management/ssh-otp) for temporary SSH access
- Configure [AWS secrets engine](/vault/docs/secrets/aws) for dynamic cloud credentials
- Configure [Azure secrets engine](/vault/docs/secrets/azure) for dynamic Azure service principals

Static secrets:

- Read the [KV secrets engine documentation](/vault/docs/secrets/kv) for static secret storage
- Learn about [versioned KV secrets engine](/vault/tutorials/secrets-management/versioned-kv) for secret versioning
- Configure [schedule-based static role rotation](/vault/docs/secrets/databases#schedule-based-static-role-rotation) for automated rotation

### External resources

- [From Vulnerabilities to Vault: How We Stopped Hard-coding Secrets and Started Using HashiCorp Vault](https://journal.hexmos.com/how-to-use-hashicorp-vault/)
- [External Secrets Operator Vault Dynamic Secret](https://external-secrets.io/latest/api/generator/vault/)
- [GitOps Secrets with Argo CD, HashiCorp Vault and the External Secret Operator](https://codefresh.io/blog/gitops-secrets-with-argo-cd-hashicorp-vault-and-the-external-secret-operator/)
- [Use HashiCorp Vault's Dynamic Secrets](https://www.cockroachlabs.com/docs/stable/vault-db-secrets-tutorial)

## Static secrets

Vault lets you manage static secrets with the [KV (key/value) secrets engine](/vault/docs/secrets/kv). After you enable a KV secrets engine in Vault, users can create static key/value secrets, like passwords, API keys, and certificates. CI/CD pipelines can authenticate with Vault, and retrieve these secrets instead of using secrets stored in code, files, or environment variables.

The following are common use cases for static secrets in CI/CD pipelines:

- **Third-party API keys**: External service credentials
- **Shared certificates**: SSL/TLS certificates used by multiple services
- **Legacy systems**: Systems that can't use dynamic secrets
- **Configuration values**: Non-dynamic configuration data

Consider a CI/CD pipeline job that requires access to a Google service. Vault can use the KV secrets engine to store the Google API key as a static secret. When the pipeline runs, the job authenticates with Vault and retrieves the API key, allowing secure access to the Google service without exposing sensitive credentials in code or configuration files.

### Static secrets example

This example shows a CI/CD pipeline retrieving static secrets from Vault's KV secrets engine:

```bash
# Authenticate to Vault using CI/CD platform's OIDC token
export VAULT_TOKEN=$(vault write -field=token auth/jwt/login \
  role=ci-cd-role \
  jwt=$CI_JOB_JWT_V2)

# Retrieve static secrets from KV secrets engine
export GOOGLE_API_KEY=$(vault kv get -field=api_key secret/google/production)
export SIGNING_KEY=$(vault kv get -field=key secret/signing/production)
export WEBHOOK_SECRET=$(vault kv get -field=secret secret/webhook/production)

# Use static secrets in deployment
./deploy.sh --api-key="$GOOGLE_API_KEY" --signing-key="$SIGNING_KEY"
```

Static secrets remain the same across pipeline runs until manually rotated in Vault. This approach works well for third-party API keys and other credentials that cannot be dynamically generated.

## HashiCorp resources

- [Versioned key/value secrets engine](/vault/tutorials/secrets-management/versioned-kv)

## Performance considerations

When choosing between dynamic and static secrets for your CI/CD pipelines, consider the following performance trade-offs:

- **Dynamic secret latency:** Each dynamic secret request requires Vault to generate credentials from the external service, adding latency to pipeline execution. Use appropriate TTLs to balance security with performance, and configure [Vault telemetry](/vault/docs/internals/telemetry/enable-telemetry) to monitor secret generation times.
- **Caching strategies:** Use [Vault Agent caching](/vault/docs/agent-and-proxy/agent/caching) or Vault Proxy to reduce direct Vault API calls from high-frequency pipelines. Caching is especially effective for static secrets that do not change between pipeline runs.
- **Rate limiting:** High-frequency pipelines running in parallel can generate significant Vault API traffic. Configure [rate limit quotas](/vault/docs/configuration/create-rate-limit-quota) to protect your Vault cluster from excessive load.
- **Static vs dynamic trade-offs:** Static secrets have lower retrieval latency because Vault reads from storage instead of generating credentials. Dynamic secrets add per-request latency but provide better security posture through automatic expiration. Choose based on your pipeline frequency and security requirements.

## Next steps

In this overview of dynamic and static secrets in CI/CD, you learned that you can use both types of secrets depending on your security requirements and workflow. Dynamic secrets are generated on-demand and have a short lifespan, while static secrets are long-lived credentials that you manually create and store. You can use HashiCorp Vault to manage both types of secrets in your CI/CD pipelines.

In this section of [managing CI/CD secrets](/well-architected-framework/secure-systems/secure-applications/ci-cd-secrets), you the learned about dynamic and static secrets, and which type to use in your use-case. CI/CD dynamic and static secrets is part of the [Secure systems pillar](/well-architected-framework/secure-systems).