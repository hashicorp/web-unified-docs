---
page_title: Dynamic and static secrets in CI/CD
description: Compare dynamic and static secrets in CI/CD pipelines. Learn when to use short-lived credentials versus static secrets with Vault rotation policies.
---

# Dynamic and static secrets in CI/CD

CI/CD pipelines require access to secrets like database credentials, API keys, and cloud provider credentials. You can use two types of secrets in your pipelines: dynamic secrets that are generated on-demand and automatically expire, or static secrets that are manually created and remain until explicitly changed. Understanding the differences helps you choose the right approach for your security requirements and operational constraints.

## Comparing secret types

| Aspect | Dynamic Secrets | Static Secrets |
|--------|----------------|----------------|
| **Creation** | Generated by Vault on-demand | Manually created and stored |
| **Lifecycle** | Automatic expiration/revocation | Manual rotation/revocation |
| **Lifespan** | Short-lived (minutes to hours) | Long-lived (until changed) |
| **Uniqueness** | Unique per request | Shared across users/systems |
| **Auditing** | Detailed per-request tracking | Limited audit capabilities |
| **Risk** | Lower (minimal exposure time) | Higher (persistent credentials) |
| **Setup complexity** | Higher (requires secrets engine configuration) | Lower (simple key-value storage) |
| **Operational overhead** | Lower (automatic rotation) | Higher (manual rotation required) |

## Understanding dynamic and static roles

When working with database secrets engines, Vault supports two different approaches for managing credentials: dynamic roles and static roles. Understanding the difference helps you choose the right pattern for your CI/CD pipelines.

**Dynamic roles** generate completely new database users on-demand. When your pipeline requests credentials from a dynamic role, Vault creates a new database user with a unique username and password. When the lease expires, Vault deletes the entire database user. This approach provides maximum isolation because each pipeline run gets its own dedicated database user, making audit trails precise and preventing credential reuse. Use dynamic roles for short-lived access, CI/CD pipelines, and ephemeral workloads where you need strong auditing of which specific pipeline run accessed which data.

**Static roles** manage existing database users by rotating only the password. Vault maintains a one-to-one mapping between a Vault role and a pre-existing database username. When your pipeline requests credentials from a static role, Vault returns the fixed username with the current password, which Vault automatically rotates on a schedule. The username never changes, only the password is updated periodically. Use static roles for long-lived applications that require specific database usernames, legacy systems that cannot handle dynamic user creation, or when you need to maintain consistent database user configurations like grants and permissions.

For CI/CD pipelines, dynamic roles are generally preferred because they provide unique credentials per pipeline run with precise audit trails showing which specific pipeline execution accessed which database resources.

## When to use dynamic secrets

Use dynamic secrets when the external service supports programmatic credential generation:

**Cloud providers:** AWS, Azure, GCP secrets engines generate temporary access credentials with automatic expiration. Ideal for deployments that interact with cloud resources.

**Databases:** Database secrets engine creates unique credentials for each pipeline run with automatic revocation. Use for applications that need database access during deployment or testing.

**PKI certificates:** PKI secrets engine issues short-lived certificates for mutual TLS authentication. Ideal for service-to-service communication in microservices deployments.

**Benefits:**
- **Reduced risk:** Compromised credentials automatically expire
- **Automatic cleanup:** No manual revocation required
- **Unique tracking:** Each credential tied to specific pipeline run
- **Better auditing:** Clear audit trail of credential usage

## When to use static secrets

Use static secrets when dynamic generation is not possible or practical:

**Third-party API keys:** External services that don't support programmatic credential generation require static API keys stored in Vault's KV secrets engine.

**Shared certificates:** SSL/TLS certificates used by multiple services benefit from centralized storage with versioning and access control.

**Legacy systems:** Applications that cannot integrate with dynamic secrets engines can retrieve static credentials from Vault instead of storing them in code or configuration files.

**Configuration values:** Non-sensitive configuration data that requires centralized management and audit trails.

**Considerations:**
- Implement [rotation policies](/vault/docs/secrets/databases#schedule-based-static-role-rotation) to minimize exposure windows
- Use [versioned KV secrets engine](/vault/tutorials/secrets-management/versioned-kv) to track secret changes
- Configure appropriate TTLs for Vault tokens accessing static secrets

## CI/CD workflow example

The following example demonstrates a complete CI/CD workflow using dynamic database credentials. This pattern applies to any CI/CD platform like GitHub Actions, GitLab CI, CircleCI, or Jenkins.

```bash
# Step 1: Authenticate to Vault (using AppRole, JWT, or other auth method)
export VAULT_ADDR="https://vault.example.com:8200"
export VAULT_TOKEN=$(vault write -field=token auth/approle/login \
  role_id=$ROLE_ID \
  secret_id=$SECRET_ID)

# Step 2: Request dynamic database credentials
DB_CREDS=$(vault read -format=json database/creds/readonly-role)
DB_USERNAME=$(echo $DB_CREDS | jq -r '.data.username')
DB_PASSWORD=$(echo $DB_CREDS | jq -r '.data.password')
LEASE_ID=$(echo $DB_CREDS | jq -r '.lease_id')

echo "Generated database user: $DB_USERNAME"

# Step 3: Use credentials in your pipeline
psql -h database.example.com -U $DB_USERNAME -d production <<EOF
  -- Run database migrations
  SELECT version FROM schema_migrations ORDER BY version DESC LIMIT 1;

  -- Run integration tests
  SELECT COUNT(*) FROM users WHERE created_at > NOW() - INTERVAL '1 day';
EOF

# Step 4: Deploy application with credentials
export DATABASE_URL="postgresql://$DB_USERNAME:$DB_PASSWORD@database.example.com/production"
./deploy.sh

# Step 5: Revoke credentials early if pipeline completes successfully
# This reduces the exposure window even further
vault lease revoke $LEASE_ID

# Step 6: Credentials automatically expire after TTL
# If revocation fails or is skipped, Vault still deletes the user when lease expires
# No manual cleanup required
```

This workflow ensures each pipeline run receives unique credentials that are automatically cleaned up, providing a precise audit trail and minimizing the risk window for compromised credentials.

## Configuration example

Setting up dynamic secrets for CI/CD requires configuring the secrets engine, creating roles with appropriate permissions, and defining policies. The following example shows PostgreSQL configuration, but the pattern applies to MySQL, MongoDB, and other supported databases.

**Enable the database secrets engine:**

```bash
vault secrets enable database
```

**Configure the database connection:**

```bash
vault write database/config/postgresql \
  plugin_name=postgresql-database-plugin \
  allowed_roles="readonly-role,readwrite-role" \
  connection_url="postgresql://{{username}}:{{password}}@postgres.example.com:5432/production" \
  username="vault-admin" \
  password="vault-admin-password"
```

**Create a dynamic role for read-only CI/CD access:**

```bash
vault write database/roles/readonly-role \
  db_name=postgresql \
  creation_statements="CREATE ROLE \"{{name}}\" WITH LOGIN PASSWORD '{{password}}' VALID UNTIL '{{expiration}}'; \
    GRANT SELECT ON ALL TABLES IN SCHEMA public TO \"{{name}}\";" \
  default_ttl="1h" \
  max_ttl="24h"
```

**Create a dynamic role for deployment pipelines with write access:**

```bash
vault write database/roles/readwrite-role \
  db_name=postgresql \
  creation_statements="CREATE ROLE \"{{name}}\" WITH LOGIN PASSWORD '{{password}}' VALID UNTIL '{{expiration}}'; \
    GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO \"{{name}}\";" \
  default_ttl="30m" \
  max_ttl="2h"
```

**Create a Vault policy for CI/CD pipelines:**

```hcl
# ci-readonly-policy.hcl
path "database/creds/readonly-role" {
  capabilities = ["read"]
}
```

**Attach the policy to your auth method role:**

```bash
# For AppRole authentication
vault write auth/approle/role/ci-readonly \
  token_policies="ci-readonly-policy" \
  token_ttl=15m \
  token_max_ttl=1h

# For JWT/OIDC authentication
vault write auth/jwt/role/ci-readonly \
  role_type="jwt" \
  bound_claims='{"repository":"myorg/myrepo"}' \
  user_claim="sub" \
  token_policies="ci-readonly-policy" \
  token_ttl=15m
```

Vault now generates unique PostgreSQL credentials for each pipeline run that automatically expire after the configured TTL.

## Best practices for dynamic secrets in CI/CD

The following best practices help you optimize security and operations when using dynamic secrets in CI/CD pipelines:

- **Set appropriate TTLs based on pipeline duration:** Configure `default_ttl` to match your typical pipeline execution time and `max_ttl` for the absolute maximum duration. For a 30-minute pipeline, set `default_ttl="1h"` to provide buffer time and `max_ttl="2h"` to prevent indefinite extensions. Short TTLs reduce the risk window if credentials are compromised.

- **Implement least-privilege roles:** Create separate Vault roles for different access levels rather than granting broad permissions. Define a read-only role for test pipelines that only need to verify data, and a separate read-write role for deployment pipelines that modify database state. Grant only the specific permissions each pipeline needs.

- **Revoke leases early when pipelines complete:** Use `vault lease revoke $LEASE_ID` at the end of successful pipeline runs to delete credentials immediately rather than waiting for TTL expiration. This reduces the exposure window from hours to minutes. Implement this in a cleanup step that runs even if previous steps fail.

- **Handle credential retrieval failures gracefully:** Wrap Vault API calls in error handling that fails the pipeline if credentials cannot be retrieved. Check for empty responses, invalid JSON, or connection errors before attempting to use credentials. Log errors with enough detail for debugging but avoid exposing credential values in logs.

- **Validate credentials before use:** Test database connectivity with retrieved credentials before proceeding with migrations or deployments. A simple connection test helps catch configuration errors, network issues, or permission problems early in the pipeline rather than discovering them during critical deployment steps.

- **Monitor lease creation and expiration rates:** Track how many leases your pipelines create per hour and monitor for unusual spikes that might indicate compromised credentials or misconfigured pipelines. Set up alerts for lease exhaustion on your database to prevent service disruption when too many dynamic users are created simultaneously.

- **Use connection pooling carefully with dynamic credentials:** Dynamic credentials that expire during application runtime can break connection pools. For long-running applications, either use static secrets with rotation or implement connection pool refresh logic that obtains new credentials before the lease expires. For short-lived CI/CD pipelines, this is typically not a concern.

## Performance considerations

**Dynamic secret latency:** Each dynamic secret request requires Vault to generate credentials from the external service, adding latency to pipeline execution. Use appropriate TTLs to balance security with performance.

**Caching strategies:** Use [Vault Agent caching](/vault/docs/agent-and-proxy/agent/caching) or Vault Proxy to reduce direct Vault API calls from high-frequency pipelines. Caching is especially effective for static secrets.

**Rate limiting:** Configure [rate limit quotas](/vault/docs/configuration/create-rate-limit-quota) to protect your Vault cluster from excessive load when running many pipelines in parallel.

**Static vs dynamic trade-offs:** Static secrets have lower retrieval latency but require manual rotation. Dynamic secrets add per-request latency but provide better security posture through automatic expiration.

## HashiCorp resources

Secrets management patterns:

- Learn about [using dynamic credentials for secure authentication](/well-architected-framework/secure-systems/identity-access-management/use-dynamic-credentials) for broader authentication patterns
- Review [secret rotation strategies](/well-architected-framework/secure-systems/secrets/rotate-secrets) for protecting your applications
- Explore [securing static secrets with key/value storage](/well-architected-framework/secure-systems/secrets/store-static-secrets) for long-lived credentials

Understanding secrets types:

- Complete the [Understand dynamic secrets tutorial](/vault/tutorials/get-started/understand-static-dynamic-secrets) to learn the differences between secret types
- Read about [secrets engines](/vault/docs/secrets) for an overview of Vault's secrets management capabilities

Dynamic secrets:

- Learn about [database credential rotation](/vault/tutorials/db-credentials) for dynamic database credentials
- Explore [dynamic secrets for AWS authentication](/vault/tutorials/db-credentials/database-secrets) for S3 access
- Use the [SSH secrets engine for one-time passwords](/vault/tutorials/secrets-management/ssh-otp) for temporary SSH access
- Configure [AWS secrets engine](/vault/docs/secrets/aws) for dynamic cloud credentials
- Configure [Azure secrets engine](/vault/docs/secrets/azure) for dynamic Azure service principals

Static secrets:

- Read the [KV secrets engine documentation](/vault/docs/secrets/kv) for static secret storage
- Learn about [versioned KV secrets engine](/vault/tutorials/secrets-management/versioned-kv) for secret versioning
- Configure [schedule-based static role rotation](/vault/docs/secrets/databases#schedule-based-static-role-rotation) for automated rotation

### External resources

- [From Vulnerabilities to Vault: How We Stopped Hard-coding Secrets and Started Using HashiCorp Vault](https://journal.hexmos.com/how-to-use-hashicorp-vault/)
- [External Secrets Operator Vault Dynamic Secret](https://external-secrets.io/latest/api/generator/vault/)
- [GitOps Secrets with Argo CD, HashiCorp Vault and the External Secret Operator](https://codefresh.io/blog/gitops-secrets-with-argo-cd-hashicorp-vault-and-the-external-secret-operator/)
- [Use HashiCorp Vault's Dynamic Secrets](https://www.cockroachlabs.com/docs/stable/vault-db-secrets-tutorial)

## Next steps

In this section of [managing CI/CD secrets](/well-architected-framework/secure-systems/secure-applications/ci-cd-secrets), you learned about dynamic and static secrets for CI/CD pipelines. Dynamic and static secrets is part of the [Secure systems pillar](/well-architected-framework/secure-systems).

- Review the [CI/CD secrets overview](/well-architected-framework/secure-systems/secure-applications/ci-cd-secrets) for architectural guidance across platforms
