---
page_title: data block reference
description: Learn how to configure a `data` block that gets data from the specified data source for use in the configuration.
---

# `data` block reference

The `data` block fetches data about a resource from the provider without provisioning an associated infrastructure object. You can reference data source attributes to configure other resources, keeping your configuration dynamic and preventing hardcoding. Refer to [Query infrastructure data](/terraform/language/data-sources) for more information.

The source type, arguments, and attributes depend on the provider. Refer to the provider documentation for more information.

## Configuration model

The `data` block supports the following configuration:

- [`data "<TYPE>" "<LABEL>"`](#data) &nbsp block
  - [provider-specific arguments](#provider-specific-arguments) &nbsp block | refer to your provider documentation
  - [`count`](#count) &nbsp number | mutually exclusive with `for_each`
  - [`depends_on`](#depends_on) &nbsp list of references
  - [`for_each`](#for_each) &nbsp map or set of strings | mutually exclusive with `count`
  - [`provider`](#provider) &nbsp reference
  - [`lifecycle`](#lifecycle) &nbsp block
    - [`precondition`](#precondition) &nbsp block
      - [`condition`](#precondition) &nbsp string
      - [`error_message`](#precondition) & nbsp string
    - [`postcondition`](#postcondition) &nbsp block
      - [`condition`](#postcondition) &nbsp string
      - [`error_message`](#postcondition) &nbsp string

## Complete configuration

The following `data` block includes all built-in arguments supported in a data source:

```hcl
data "<TYPE>" "<LABEL>" {
   <PROVIDER-SPECIFIC ARGUMENTS>
   count = <NUMBER>      # `count` and `for_each` are mutually exclusive
   depends_on = [ <RESOURCE.ADDRESS.EXPRESSION> ]
   for_each = {          # `for_each` and `count` are mutually exclusive
      <KEY> = <VALUE>
   }
   for_each = [       # `for_each` accepts a map or a set of strings
    "<VALUE>",
    "<VALUE>"
   ]
   provider = <REFERENCE.TO.ALIAS>
   lifecycle {
      precondition {
         condition = <EXPRESSION>
         error_message = "<STRING>"
    }
    postcondition {
      condition = <EXPRESSION>
      error_message = "<STRING>"
    }
  }
}
```

## Specification

A `data` block supports the following configuration.

### `data "<TYPE>" "<LABEL>"`

You must set the following arguments for every `data` block:

- `TYPE`: Specifies the data source type. Provider developers define the support data sources. Refer to the provider documentation for details. Terraform also includes the [`terraform_remote_state` data source](/terraform/language/state/remote-state-data), which lets you access state data from other workspaces.
- `LABEL`: Specifies a name for the data source. Use the `data.<label>.<attribute>` syntax to reference the data. Refer to [References to Named Values](/terraform/language/expressions/references) and [Resource naming](/terraform/language/style#resource-naming) for expression syntax and label recommendations.

### Provider-specific arguments

The provider developer determines which arguments you can define for a data source. Refer to the provider documentation for details.

### `count`

The `count` meta-argument instructs Terraform to provision multiple instances of the same data source with identical or similar configuration. You cannot use both a `count` and ` for_each` argument in the same block.

```hcl
data "<TYPE>" "<LABEL>" {
  count = <number>
}
```

`count` is a **meta-argument**. Meta-arguments are built into the Terraform language and control how Terraform creates resources. Refer to the [`count` reference](/terraform/language/meta-arguments/count) for details about how the argument works.


### `depends_on`

The `depends_on` meta-argument specifies an upstream resource that the data source depends on. Terraform must complete all operations on the upstream resource before performing operations on the data source containing the `depends_on` argument.

```
data "<TYPE>" "<LABEL>" {
  depends_on = [ <resource reference> ]
}
```

`depends_on` is a **meta-argument**. Meta-arguments are built into the Terraform language and control how Terraform creates resources. Refer to the [`depends_on` reference](/terraform/language/meta-arguments/depends_on) for details about how the argument works.

### `for_each`

The `for_each` meta-argument instructs Terraform to provision similar resources without requiring separate configuration blocks for each resource.

<Tabs>

<Tab heading="List of values">

```hcl
data "<TYPE>" "<LABEL>" {
  for_each = [ "<VALUE>" ]
  # . . .
}
```

</Tab>

<Tab heading="Map of key-value pairs">

```hcl
data "<TYPE>" "<LABEL>" {
  for_each = {
    "<KEY>" = "<VALUE>"
  }
}
```

</Tab>

</Tabs>

`for_each` is a **meta-argument**. Meta-arguments are built into the Terraform language and control how Terraform creates resources. Refer to the [`for_each` reference](/terraform/language/meta-arguments/for_each) for details about how the argument works.


### `provider`

The `provider` argument instructs Terraform to use an alternate provider configuration.

```hcl
data "<TYPE>" "<LABEL>" {
  provider = <provider>.<alias>
}
```

By default, Terraform automatically selects a provider based on the data source type, but you can create multiple provider configurations and use a non-default configuration for specific data sources.

Use the `<PROVIDER>.<ALIAS>` syntax to reference a provider configuration in the `provider` argument. Refer to [Using an alternate provider configuration](/terraform/language/block/provider#using-an-alternate-provider-configuration) for an example of how to reference a specific provider configuration.

The `provider` argument is a meta-argument, which is built into Terraform and controls the way that Terraform creates resources. Refer to [Meta-arguments](/terraform/language/meta-arguments) for more information.

#### Summary

- Data type: Reference.
- Default: None.

### `lifecycle`

The `lifecycle` block defines lifecycle rules for how Terraform operates on your data source.

```hcl
data "<TYPE>" "<LABEL>" {
  lifecycle {
    <lifecycle>
  }
}
```

You can specify the following lifecycle rules to manage how Terraform performs operations on the resource:

- [`precondition`](#precondition): Specifies a condition that Terraform evaluates before creating the data source. Refer to [Validate your configuration](/terraform/language/validate) for more information.
- [`postcondition`](#postcondition): Specifies a condition that Terraform evaluates after creating the data source. Refer to [Validate your configuration](/terraform/language/validate) for more information.

Configurations defined in the `lifecycle` block affect how Terraform constructs and traverses the dependency graph. You can only use literal values in the lifecycle block because Terraform processes them before it evaluates arbitrary expressions for a run.

The `lifecycle` block is a meta-argument. Meta-arguments are built-in arguments that control how Terraform creates data sources. Refer to [Meta-arguments](/terraform/language/meta-arguments) for more information.

#### Summary

- Data type: Block.
- Default: None.

### `precondition`

The `precondition` block specifies a condition that must return `true` before Terraform evaluates and performs operations on the data source. You can also specify an error message for Terraform to print when the condition returns `false`.

```hcl
resource {
  lifecycle {
    precondition {
      condition = <expression>
      error_message = "<message>"
    }
  }
}
```

The following arguments in the `precondition` block are required:

| Argument | Description | Data type |
| --- | --- | --- |
| `condition` | Expression that must return `true` for Terraform to proceed with an operation. You can refer to any other object in the same configuration scope unless the reference creates a cyclic dependency. | Expression that can include references, strings, and operators. |
| `error_message` | Message that Terraform prints to the console if the `condition` returns `false`. | String |

Terraform evaluates `precondition` blocks before evaluating the resource's configuration arguments. The `precondition` can take precedence over argument evaluation errors.

Terraform evaluates precondition blocks after evaluating [`count`](#count) and [`for_each`](#for_each) meta-arguments. As a result, Terraform can evaluate the `precondition` separately for each instance and makes the `each.key` and `count.index` objects available in the conditions.

You can include a `precondition` and [`postcondition` block](#postcondition) in the same resource. Do not add `precondition` blocks to a `resource` block and a `data` block that represent the same object in the same configuration. Doing so may cause Terraform to ignore changes to the `data` block that result from changes in the `resource` block.

Refer to [Validate your configuration](/terraform/language/validate) for information about adding validations to your Terraform configuration.

 #### Summary

- Data type: Block.
- Default: None.
- Example: [Apply custom conditions](#apply-custom-conditions).

### `postcondition`

The `postcondition` block specifies a condition that must return `true` after Terraform performs operations on the data source. You can also specify an error message for Terraform to print to the console when the condition returns `false`.

```hcl
data "<TYPE>" "<LABEL>" {
  lifecycle {
    postcondition {
      condition = <expression>
      error_message = "<message>"
    }
  }
}
```

The following arguments in the `precondition` block are required:

| Argument | Description | Data type |
| --- | --- | --- |
| `condition` | Expression that must return `true` for Terraform to perform operations on downstream resources. You can refer to any other object in the same configuration scope unless the reference creates a cyclic dependency. | Expression that can include references, strings, and operators. |
| `error_message` | Message that Terraform prints to the console if the `condition` returns `false`. | String |

Terraform evaluates `postcondition` blocks after planning and applying changes to the data source. Postcondition failures prevent changes to other resources that depend on the failing resource.

You can include a `postcondition` and [`precondition` block](#precondition) in the same resource. Do not add `postcondition` blocks to a `resource` block and a `data` block that represent the same object in the same configuration. Doing so may cause Terraform to ignore changes to the `data` block that result from changes in the `resource` block.

Refer to [Validate your configuration](/terraform/language/validate) for information about adding validations to your Terraform configuration.

#### Summary

- Data type: Block.
- Default: None.
- Example: [Apply custom conditions](#apply-custom-conditions).

## Examples

The following examples show how to write configuration for common use cases.

### Select an alternate provider configuration

In the following example, the `google_compute_instance` data source selects the provider configuration with the `europe` alias.

```hcl
provider "google" {
  region = "us-central1"
}

provider "google" {
  alias  = "europe"
  region = "europe-west1"
}

data "google_compute_instance" "example" {
  provider = google.europe
  # ...
}
```

### Apply custom conditions

The following example includes several configurations that illustrate how to define `precondition` and `postcondition` arguments in the `lifecycle` meta-argument.

The following `data` block instructs Terraform to retrieve the ID of the `ami-abc123` AMI:

```hcl
data "aws_ami" "example" {
  owners = ["amazon"]
  filter {
    name   = "image-id"
    values = ["ami-abc123"]
  }
}
```

In the following code, the `precondition` block specifies that the AMI ID retrieved from the `data` block must include `x86_64` as its `architecture` attribute. The `postcondition` block specifies that the EC2 instance must be allocated a public DNS hostname. When either condition is not met, Terraform returns the `error_message` for the failed condition:

```hcl
resource "aws_instance" "example" {
  instance_type = "t3.micro"
  ami           = data.aws_ami.example.id

  lifecycle {
    precondition {
      condition     = data.aws_ami.example.architecture == "x86_64"
      error_message = "The selected AMI must be for the x86_64 architecture."
    }

    postcondition {
      condition     = self.public_dns != ""
      error_message = "EC2 instance must be in a VPC that has public DNS hostnames enabled."
    }
  }
}
```

The following `data` block retrieves the root storage volume connected to the `aws_instance.example` EC2 instance using the `volume_id` attribute. When a `data` resource verifies the result of a managed resource declared in the same configuration, you must define the check in a `postcondition` block in the resource so that Terraform waits for changes to the managed resource to complete before reading the data resource.

```hcl
data "aws_ebs_volume" "example" {
  filter {
    name = "volume-id"
    values = [aws_instance.example.root_block_device[0].volume_id]
  }
  lifecycle {
    # The EC2 instance will have an encrypted root volume.
    postcondition {
      condition     = self.encrypted
      error_message = "The server's root volume is not encrypted."
    }
  }
}
output "api_base_url" {
  value = "https://${aws_instance.example.private_dns}:8433/"
}
```
