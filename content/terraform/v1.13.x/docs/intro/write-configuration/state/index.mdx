---
page_title: State
description: >-
  An introduction to state, information that Terraform uses to map resources to
  a configuration, track metadata, and improve performance.
---

# State

Terraform must store state about your managed infrastructure and
configuration. This state is used by Terraform to map real world
resources to your configuration, keep track of metadata, and to improve
performance for large infrastructures.

This state is stored by default in a local file named "terraform.tfstate",
but we recommend [storing it in HCP Terraform](/terraform/cloud-docs/migrate)
to version, encrypt, and securely share it with your team.

Terraform uses state to determine which changes to make to your
infrastructure. Prior to any operation, Terraform does a
[refresh](/terraform/cli/commands/refresh) to update the state with the
real infrastructure.

The primary purpose of Terraform state is to store bindings between objects in
a remote system and resource instances declared in your configuration.
When Terraform creates a remote object in response to a change of configuration,
it will record the identity of that remote object against a particular
resource instance, and then potentially update or delete that object in
response to future configuration changes.

For more information on why Terraform requires state and why Terraform cannot
function without state, please see the page [state purpose](/terraform/language/state/purpose).

## Inspection and Modification

While the format of the state files are just JSON, direct file editing
of the state is discouraged. Terraform provides the
[terraform state](/terraform/cli/commands/state) command to perform
basic modifications of the state using the CLI.

The CLI usage and output of the state commands is structured to be
friendly for Unix tools such as grep, awk, etc. Additionally, the CLI
insulates users from any format changes within the state itself. The Terraform
project will keep the CLI working while the state format underneath it may
shift.

Terraform expects a one-to-one mapping between configured resource instances
and remote objects. Normally that is guaranteed by Terraform being the one
to create each object and record its identity in the state, or to destroy
an object and then remove the binding for it.

If you add or remove bindings in the state by other means, such as by importing
externally-created objects with `terraform import`, or by asking Terraform to
"forget" an existing object with `terraform state rm`, you'll then need to
ensure for yourself that this one-to-one rule is followed, such as by manually
deleting an object that you asked Terraform to "forget", or by re-importing it
to bind it to some other resource instance.

## Format

State snapshots are stored in JSON format and new Terraform versions are
generally backward compatible with state snapshots produced by earlier versions.
However, the state format is subject to change in new Terraform versions, so
if you build software that parses or modifies it directly you should expect
to perform ongoing maintenance of that software as the state format evolves
in new versions.

Alternatively, there are several integration points which produce JSON output
that is specifically intended for consumption by external software:

* [The `terraform output` command](/terraform/cli/commands/output)
  has a `-json` option, for obtaining either the full set of root module output
  values or a specific named output value from the latest state snapshot.
* [The `terraform show` command](/terraform/cli/commands/show) has a `-json`
  option for inspecting the latest state snapshot in full, and also for
  inspecting saved plan files which include a copy of the prior state at the
  time the plan was made.

A typical way to use these in situations where Terraform is running in
automation is to run them immediately after a successful `terraform apply`
to obtain a representation of the latest state snapshot, and then store that
result as an artifact associated with the automated run so that other software
can potentially consume it without needing to run Terraform itself.

## Purpose of Terraform State

State is a necessary requirement for Terraform to function. It is often
asked if it is possible for Terraform to work without state, or for Terraform
to not use state and just inspect real world resources on every run. This page
will help explain why Terraform state is required.

As you'll see from the reasons below, state is required. And in the scenarios
where Terraform may be able to get away without state, doing so would require
shifting massive amounts of complexity from one place (state) to another place
(the replacement concept).

## Mapping to the Real World

Terraform requires some sort of database to map Terraform config to the real
world. For example, when you have a resource `resource "aws_instance" "foo"` in your
configuration, Terraform uses this mapping to know that the resource `resource "aws_instance" "foo"`
represents a real world object with the instance ID `i-abcd1234` on a remote system.

For some providers like AWS, Terraform could theoretically use something like
AWS tags. Early prototypes of Terraform actually had no state files and used
this method. However, we quickly ran into problems. The first major issue was
a simple one: not all resources support tags, and not all cloud providers
support tags.

Therefore, for mapping configuration to resources in the real world,
Terraform uses its own state structure.

Terraform expects that each remote object is bound to only one resource instance in the configuration.
If a remote object is bound to multiple resource instances, the mapping from configuration to the remote
object in the state becomes ambiguous, and Terraform may behave unexpectedly. Terraform can guarantee 
a one-to-one mapping when it creates objects and records their identities in the state. 
When importing objects created outside of Terraform, you must make sure that each distinct object 
is imported to only one resource instance.

## Metadata

Alongside the mappings between resources and remote objects, Terraform must
also track metadata such as resource dependencies.

Terraform typically uses the configuration to determine dependency order.
However, when you delete a resource from a Terraform configuration, Terraform
must know how to delete that resource from the remote system. Terraform can see that a mapping exists
in the state file for a resource not in your configuration and plan to destroy. However, since
the configuration no longer exists, the order cannot be determined from the
configuration alone.

To ensure correct operation, Terraform retains a copy of the most recent set
of dependencies within the state. Now Terraform can still determine the correct
order for destruction from the state when you delete one or more items from
the configuration.

Terraform could take another approach to dependency order by using an underlying hierarchy of order
between resource types. For example, Terraform could know that servers must be
deleted before the subnets they are a part of. The complexity for this approach
quickly explodes, however: in addition to Terraform having to understand the
ordering semantics of every resource for every _provider_, Terraform must also
understand the ordering _across providers_.

Terraform also stores other metadata for similar reasons, such as a pointer
to the provider configuration that was most recently used with the resource
in situations where multiple aliased providers are present.

## Performance

In addition to basic mapping, Terraform stores a cache of the attribute
values for all resources in the state. This is the most optional feature of
Terraform state and is done only as a performance improvement.

When running a `terraform plan`, Terraform must know the current state of
resources in order to effectively determine the changes that it needs to make
to reach your desired configuration.

For small infrastructures, Terraform can query your providers and sync the
latest attributes from all your resources. This is the default behavior
of Terraform: for every plan and apply, Terraform will sync all resources in
your state.

For larger infrastructures, querying every resource is too slow. Many cloud
providers do not provide APIs to query multiple resources at once, and the
round trip time for each resource is hundreds of milliseconds. On top of this,
cloud providers almost always have API rate limiting so Terraform can only
request a certain number of resources in a period of time. Larger users
of Terraform make heavy use of the `-refresh=false` flag as well as the
`-target` flag in order to work around this. In these scenarios, the cached
state is treated as the record of truth.

## Syncing

In the default configuration, Terraform stores the state in a file in the
current working directory where Terraform was run. This is okay for getting
started, but when using Terraform in a team it is important for everyone
to be working with the same state so that operations will be applied to the
same remote objects.

[Remote state](/terraform/language/state/remote) is the recommended solution
to this problem. With a fully-featured state backend, Terraform can use
remote locking as a measure to avoid two or more different users accidentally
running Terraform at the same time, and thus ensure that each Terraform run
begins with the most recent updated state.
