---
layout: docs
page_title: Vault Secrets Operator CSI driver setup
description: >-
  Install the Vault Secrets Operator CSI driver and 
  mount secrets into your applications as ephemeral volumes.
---

# Set up the Vault Secrets Operator CSI driver

@include 'alerts/enterprise-only.mdx'

Use the Vault Secrets Operator CSI driver with a `CSISecrets` resource to
allow authorized pods to mount ephemeral volumes containing secrets
from Vault as indexed files. Indexing starts at `0` and represents the
associated position in the associated `vaultStaticSecrets` or
`vaultAppRoleSecretIDs` list in the `CSISecrets` resource.  For example,
`static_secret_0_secret`, `static_secret_1_secret`, etc.

## Before you start

- You must have a working Kubernetes workflow.
- Review the [Vault Secrets Operator threat model](https://github.com/hashicorp/vault-secrets-operator/tree/main/docs/threat-model).
  The simplified Kubernetes RBAC configuration examples below are not
  production-ready.
- Review any applicable regulations or requirements to understand how your
  authentication choices may impact cluster security.


## Step 1: Install driver

Install the Vault Secrets Operator Helm chart with the `csi.enabled` flag set to `true` to deploy the CSI
driver as a DaemonSet running on every node:

```shell-session
$ helm install                         \
    --version 0.10.0                   \
    --create-namespace                 \
    --namespace vault-secrets-operator \
    --set "csi.enabled=true"           \
    vault-secrets-operator             \
    hashicorp/vault-secrets-operator
```

## Step 2: Add container restarts for secret changes

The CSI driver generates and syncs new AppRole secret IDs on container startup.
All other secrets sync whenever a requesting container starts or restarts.

The CSI driver does not support [instant updates](/vault/docs/deploy/kubernetes/vso/sources/vault/instant-updates), 
so you must modify your Kubernetes workflow so containers can handle their own restarts when a Vault secret update occurs.


## Step 3: Create your Vault policies

You must create a Vault policy to allow the CSI driver to fetch secrets and/or 
generate AppRole secret IDs.
	
For example, the following policy lets the CSI driver fetch secrets from the 
Key/Value plugin:

```hcl
path "example-kv/password" {
    capabilities = ["read"]
}

path "example-kv-v2/data/api-key" {
    capabilities = ["read"]
}

path "sys/license/status" {
    capabilities = ["read"]
}
```

To generate AppRole secret IDs with the CSI driver so application pods can 
log into Vault and fetch secrets independently, your Vault policy must grant the CSI driver 
permissions for the associated role. 

For example, the following policy lets the CSI driver generate secret IDs 
using the AppRole plugin:

```
path "auth/approle/role/example-role/secret-id" {
    capabilities = ["update"]
}

path "auth/approle/role/example-role/role-id" {
    capabilities = ["read"]
}
```

Once you write the policy to Vault, you can create a role that uses that policy 
in any auth method supported by Vault Secrets Operator.

For example, to use the policy with the [Kubernetes](/vault/docs/auth/kubernetes)
auth method:
```shell-session
$ vault write auth/kubernetes/role/example-auth-role                       \
    bound_service_account_names=default                                    \
    bound_service_account_namespaces=default,vault-secrets-operator-system \
    token_period=120                                                       \
    token_policies=csi-driver-policy                                       \
    audience=vault
```


## Step 4: Create your auth custom resources

You must create a
[`VaultAuth`](/vault/docs/deploy/kubernetes/vso/api-reference#vaultauth) and
[`VaultConnection`](/vault/docs/deploy/kubernetes/vso/api-reference#vaultconnection), 
as defined in the Custom Resource Definitions (CRDs) that were deployed by the Vault Secrets Operator Helm chart, 
so the CSI driver can connect to Vault. 

Create a YAML file with these resources, and apply it to your cluster. For example:

```yaml
apiVersion: secrets.hashicorp.com/v1beta1
kind: VaultAuth
metadata:
 name: default
 namespace: vault-secrets-operator-system
spec:
 vaultAuthGlobalRef:
   name: default

---

apiVersion: secrets.hashicorp.com/v1beta1
kind: VaultAuthGlobal
metadata:
 name: default
 namespace: vault-secrets-operator-system
spec:
 defaultAuthMethod: kubernetes
 kubernetes:
   audiences:
     - vault
   mount: kubernetes
   role: example-auth-role
   serviceAccount: example-service-account
   tokenExpirationSeconds: 600

---

apiVersion: secrets.hashicorp.com/v1beta1
kind: VaultConnection
metadata:
  name: default
  namespace: vault-secrets-operator-system
spec:
  address: http://vault.vault.svc.cluster.local:8200
  skipTLSVerify: false
```

For more detailed resource examples, refer to the 
[Vault authentication in detail](/vault/docs/deploy/kubernetes/vso/sources/vault/auth) guide.

## Step 5: Create the CSISecrets resource

To securely communicate secrets between Vault and your application pods, you
must create a custom resource called `CSISecrets` that lists information
available to the CSI driver pods.

For example, the following resource definition creates a single `CSISecrets`
resource that can:

- Generate secret IDs from an `approle` auth method mounted at `auth/approle`
  for a role configured with the name `my-app`.
- Limit which pods can use the associated `CSISecrets` resource based on regular
  expression patterns in the `accessControl` field.
- Fetch secrets from a `kv` v1 secrets engine mounted at `kv1`.
- Fetch secrets from a `kv` v2 secrets engine mounted at `kv2`.

```yaml
apiVersion: secrets.hashicorp.com/v1beta1
kind: CSISecrets
metadata:
  name: my-app-secrets
  namespace: vault-secrets-operator-system
spec:
  vaultAuthRef:
    name: default
  secrets:
    vaultStaticSecrets:
      - mount: kv1
        path: app-api-key
        type: kv-v1
      - mount: kv2
        path: app-api-key
        type: kv-v2
        version: 1 # The version of the KV secret -- if not specified, defaults to the latest version
    vaultAppRoleSecretIDs:
      - role: my-app
        mount: approle
        wrapTTL: "30m"
        ttl: "1h"
        numUses: 2
  accessControl:
    serviceAccountPattern: "default"
    namespacePatterns:
      - "default"
    podNamePatterns:
      - "^my-app-"
  syncConfig:
    containerState:
      namePattern: "^(app|sidecar)$"
```

Refer to the full [CSISecrets CR API reference](/vault/docs/deploy/kubernetes/vso/api-reference#csisecrets) for additional configuration options.


## Step 6: Mount the volume to your containers

Update the deployment spec for your application:

- Add the new `CSISecrets` resource to the `volumeMounts` field
- Ensure that all pod names, namespaces, etc. match the patterns defined in the 
`accessControl` stanza of your `CSISecrets` resource, and that these pods should have access to the secret data.


For example:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app
  namespace: default
  labels:
    app.kubernetes.io/component: my-app
spec:
  selector:
    matchLabels:
      app.kubernetes.io/component: my-app
  replicas: 2
  template:
    metadata:
      labels:
        app.kubernetes.io/component: my-app
    spec:
      serviceAccountName: default
      containers:
      - name: app
        image: my-app-image:latest
        volumeMounts:
        - name: csi-secrets
          mountPath: /var/run/csi-secrets
      - name: sidecar
        image: my-app-sidecar-image:latest
        volumeMounts:
        - name: csi-secrets
          mountPath: /var/run/csi-secrets
      volumes:
      - name: csi-secrets
        csi:
          driver: csi.vso.hashicorp.com
          volumeAttributes:
            csiSecretsName: my-app-secrets
            csiSecretsNamespace: vault-secrets-operator-system
```
<Tip>

You can also use the Kubernetes
[`subPath`](https://kubernetes.io/docs/concepts/storage/volumes/#using-subpath)
field and the associated file index to limit which secret files a container can
access. For example, the following `subPath` limits access to the first `approle`
secret (`app_role_0_wrap_info.json`):
	
```yaml
volumeMounts:
- name: csi-secrets
  mountPath: /var/run/app_role_0_wrap_info.json
  subPath: app_role_0_wrap_info.json
```

</Tip>

Refer to the full
[CSISecrets CR API reference](/vault/docs/deploy/kubernetes/vso/api-reference#csisecrets)
for additional configuration options.

Next, push the new configuration so the CSI driver pod on your application pod
node responds to the request. If the update succeeds, the `kubelet` publishes
a volume containing all the secrets from the `CSISecrets` resource.
## Step 7: Verify pods can access secrets appropriately

Once a pod starts, you can verify it has access to information in the
`CSISecrets` resource by inspecting files on the configured mount. For example,
`/var/run/csi-secrets`.

