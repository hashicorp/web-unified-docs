---
layout: docs
page_title: Kubernetes integrations comparison
description: >-
  Compare Vault's Kubernetes integrations: Vault Secrets Operator, Vault Secrets Operator CSI Driver, Secrets Store CSI Provider for Vault, and Vault Agent Injector.
---

# Kubernetes integrations comparison

HashiCorp Vault provides four different integrations to help Kubernetes workloads consume secrets from Vault without modifying application code. Each integration has unique characteristics that make it suitable for different use cases.

This document compares the four integrations and provides recommendations to help you choose the right solution for your needs.

## Overview of integrations

### Vault Secrets Operator

The [Vault Secrets Operator](/vault/docs/platform/k8s/vso) synchronizes secrets from Vault to native Kubernetes Secrets. 
It operates by watching Custom Resource Definitions (CRDs) and syncing secret data from Vault to Kubernetes Secrets, which applications can consume using standard Kubernetes patterns.

**Best for:** Teams who prefer native Kubernetes workflows and want durable secret storage within the cluster.

### Vault Secrets Operator CSI Driver

The [Vault Secrets Operator CSI Driver](/vault/docs/platform/k8s/vso/vso-csi) mounts secrets directly from Vault to application containers as volumes, bypassing Kubernetes Secrets entirely. 
This integration requires **Vault Enterprise**.

**Best for:** Enterprise environments that want to avoid storing secrets in Kubernetes Secrets and etcd while maintaining efficient secret delivery.

### Secrets Store CSI Provider for Vault

The [Secrets Store CSI Provider for Vault](/vault/docs/platform/k8s/csi) uses the vendor-neutral [Secrets Store CSI driver](https://secrets-store-csi-driver.sigs.k8s.io/) to mount secrets from Vault as ephemeral volumes. 
The provider runs Vault Agent alongside the CSI driver for authentication and secret retrieval.

**Best for:** Organizations using multiple secret stores in addition to Vault, or those who prefer vendor-neutral CSI standards.

### Vault Agent Injector

The [Vault Agent Injector](/vault/docs/platform/k8s/injector) injects Vault Agent sidecar containers into pods. 
The Agent containers authenticate with Vault and render secrets to a shared memory volume for consumption by application containers.

**Best for:** Applications requiring dynamic secret rotation or direct Vault Agent functionality.

## Comparison Matrix (Properties)

| Kubernetes Integrations for Vault (consumption) Properties |  |  |  |  |
| :---- | :---- | :---- | :---- | :---- |
|  | **Vault Secrets Operator** | **Vault Secrets Operator CSI Driver** | **Secrets Store CSI Provider for Vault** | **Vault Agent Injector** |
| Supported Secret Types | Static/KV, PKI, Dynamic, Database | Static/KV, AppRole secret IDs | All | All |
| Supported Auth Methods | K8s, AppRole, GCP, AWS, JWT | Kubernetes, JWT | K8s, others with Vault Agent | K8s, others |
| Storage Model | K8s Secrets via etcd | Ephemeral volumes | Ephemeral volumes | Ephemeral volumes |
| Kubernetes Native | Yes | Yes | Yes | No |
| Secret data persistence | Persisted in etcd | Ephemeral | Ephemeral | Ephemeral |
| Secret data templating | Yes | Yes | No | Yes |
| Requires Vault for autoscaling | No | Yes | Yes | Yes |
| Can share secrets between applications | Yes | Yes | No | No |
|  |  |  |  |  |


## Use case recommendations

Choosing the appropriate integration for your environment should be based on a combination of your organizationâ€™s policies 
around secret data governance, and considerations around ease of use and system availability guarantees.

| Kubernetes Integrations for Vault (consumption) Best Fit |  |  |  |  |
| :---- | :---- | :---- | :---- | :---- |
| Org Policy Mandates | **Vault Secrets Operator** | **Vault Secrets Operator CSI Driver** | **Secrets Store CSI Provider for Vault** | **Vault Agent Injector** |
| Secret data resides only in ephemeral storage | No | Yes | Yes | Yes |
| Pod Autoscaling is dependent on Vault availability | No | Yes | Yes | Yes |
| Adoption of the K8s operator model for simplicity and consistency | Yes | Yes | Yes | No |
| Personas like admin and developer are easily separated via K8s [RBAC](https://kubernetes.io/docs/reference/access-authn-authz/rbac/) policies | Yes | Yes | No | No |
| Low resource consumption. I/O, CPU, Memory | Yes | Yes | Yes | No |
| Simple configuration | Yes | Yes | Yes | No |


### Choose Vault Secrets Operator when:

- You want native Kubernetes Secret workflows
- You need high secret availability and cluster-local caching
- You want to reduce load on Vault servers
- Your team prefers declarative Kubernetes patterns
- You need secrets available as environment variables
- You want automatic secret rotation for deployments
- Pod autoscaling should not depend on Vault availability
- You want to leverage Kubernetes RBAC for role separation
- You prefer operator patterns for simplicity and consistency

**Example scenarios:**
- Microservices architectures with many pods consuming the same secrets
- Applications that expect standard Kubernetes Secret patterns
- Environments where Vault connectivity may be intermittent
- Teams transitioning from other Kubernetes secret management solutions
- Applications requiring shared secret data across multiple pods

### Choose Vault Secrets Operator CSI Driver when:

- You have Vault Enterprise
- You want to avoid storing secrets in Kubernetes Secrets and etcd
- You need efficient secret delivery without high Vault load
- You require secret templating capabilities
- Your security policy prohibits secrets in cluster storage
- You want the benefits of Vault Secrets Operator's design but with ephemeral storage
- You need reduced resource consumption compared to Agent Injector

**Example scenarios:**
- High-security environments with strict data residency requirements
- Large-scale deployments where etcd storage is a concern
- Enterprise environments with compliance requirements around secret storage
- Applications that can restart to get updated secrets
- Organizations wanting a single Vault Secrets Operator package for all secret management needs

### Choose Secrets Store CSI Provider for Vault when:

- You use multiple secret stores beyond Vault
- You prefer vendor-neutral CSI standards
- You don't require templating

**Example scenarios:**
- Multi-cloud environments with diverse secret stores
- Teams migrating between different secret management solutions
- Environments where vendor neutrality is prioritized

### Choose Vault Agent Injector when:

- You need automatic secret rotation and renewal
- You want to leverage the capabilities of Vault Agent
- You need support for a wider variety of Vault authentication methods
- Your applications require dynamic secrets with short TTLs
- You want the widest array of supported secret engines

**Example scenarios:**
- Applications using dynamic database credentials
- Environments using Vault auth methods not supported by other integrations
- Legacy applications being containerized with minimal changes
- Applications that need secrets refreshed during runtime


## Performance considerations

Performance characteristics vary significantly between integrations based on their architectural patterns:

**Load on Vault (from lowest to highest):**
1. **Vault Secrets Operator:** Lowest load due to per-CRD connections and cluster-local caching
2. **Vault Secrets Operator CSI Driver:** Low-medium load with per-node connections  
3. **Secrets Store CSI Provider:** Higher load due to per-pod connections
4. **Agent Injector:** Highest load due to per-pod connections and sidecar pattern

**Secret availability (from highest to lowest):**
1. **Vault Secrets Operator:** Best availability due to Kubernetes Secrets acting as durable cache
2. **Vault Secrets Operator CSI Driver**, **Secrets Store CSI Provider**, **Agent Injector:** Dependent on Vault availability (ephemeral storage)

**Resource consumption:**
- **Vault Secrets Operator:** Low I/O, CPU, memory consumption
- **Vault Secrets Operator CSI Driver:** Low resource consumption, efficient design
- **Secrets Store CSI Provider:** Medium resource usage
- **Agent Injector:** Highest resource usage due to sidecar containers per pod

**Scalability:**
- **Vault Secrets Operator and Vault Secrets Operator CSI Driver:** Scale well with large numbers of pods due to shared secret data
- **Secrets Store CSI Provider and Agent Injector:** Each pod creates independent Vault connections


## Migration paths

When migrating between integrations:

1. **To Vault Secrets Operator from others:** Requires creating CRDs (VaultStaticSecret, VaultPKISecret, etc.) and updating applications to use Kubernetes Secrets
2. **To Vault Secrets Operator CSI Driver:** Requires Vault Enterprise license, creating a CSISecrets CRD, and updating pod specifications to use CSI volumes
3. **From Vault Agent Injector:** May require updating secret templates to use the SecretTransformation resource

## Next steps

For detailed implementation guidance, refer to the documentation for your chosen integration:
- [Vault Secrets Operator](/vault/docs/platform/k8s/vso)
- [Vault Secrets Operator CSI Driver](/vault/docs/platform/k8s/vso/vso-csi)
- [Secrets Store CSI Provider for Vault](/vault/docs/platform/k8s/csi)
- [Vault Agent Injector](/vault/docs/platform/k8s/injector)
