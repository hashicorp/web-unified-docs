---
layout: docs
page_title: Deploy Vault on Google Kubernetes Engine (GKE)
description: >-
  Guide to deploying and setting up Vault on Google Kubernetes Engine (GKE).
---

# Deploy Vault on Google Kubernetes Engine (GKE)

Google Kubernetes Engine (GKE) can run Vault in its secured and managed
Kubernetes service in standard or autopilot mode. Standard mode gives you the flexibility to configure the cluster's underlying infrastructure while autopilot mode gives you an optimized cluster with a hands-off experience.

In this tutorial, you create a cluster in GKE, install Vault in
high-availability (HA) mode via the Helm chart and then configure the
authentication between Vault and the cluster. Then you deploy a web application with deployment annotations and the Vault Agent injector service installs the application's secrets.

## Prerequisites

This guide focuses on setting up HashiCorp Vault on Google Kubernetes Engine (GKE) and assumes a understanding of both Google Cloud and Kubernetes concepts and terminology. The guide assumes the user is familiar with Google Cloud projects, GKE, Kubernetes pods, service accounts, and manifests.

This guide requires:

- [Google Cloud account](https://console.cloud.google.com)
   - A project initialized and 
   - Google container service (`container.googleapis.com`) enabled.
- [Google Cloud command-line interface (CLI)](https://cloud.google.com/sdk/docs/quickstart)
- [Kubernetes CLI](https://kubernetes.io/docs/tasks/tools/install-kubectl/)
- [Helm CLI](https://helm.sh/docs/helm/)
- [jq](https://jqlang.org/)

In addition you need to have the Vault Helm chart. You can add the Helm repositories with the following commands:

```shell-session
$ helm repo add hashicorp https://helm.releases.hashicorp.com
```

The user should log in to Google Cloud via the CLI and have a project and region selected.

## Step 1: Start cluster

A high-availability Vault cluster requires a Kubernetes cluster with three nodes. You can manually create these nodes or use the Autopilot mode. Autopilot mode manages the underlying infrastructure and provisions nodes as needed.

1. Create a cluster in Autopilot mode named `learn-vault`.

   ```shell-session
   $ gcloud container clusters create-auto learn-vault
   ```

   After cluster creation and deployment, and it is then health-checked. When the cluster is
   ready the command modifies the `kubectl` configuration so that it performs the commands you
   issue against that cluster.

   Autopilot displays a smaller set of nodes but provisions more as needed. 

## Step 2: Install Vault

The Vault Helm chart contains all the necessary components to run Vault in several different modes.

1. Create a file named `helm-vault-raft-values.yml` with the following contents:

   ```shell-session
   $ cat > helm-vault-raft-values.yml <<EOF
   server:
      affinity: ""
      ha:
         enabled: true
         raft:
            enabled: true
            setNodeId: true
            config: |
               cluster_name = "vault-integrated-storage"
               storage "raft" {
                  path    = "/vault/data/"
               }

               listener "tcp" {
                  address = "[::]:8200"
                  cluster_address = "[::]:8201"
                  tls_disable = "true"
               }
               service_registration "kubernetes" {}
   EOF
   ```

   <Note title="Recommendation">

   If you are using Prometheus for monitoring and alerting, we recommend to set the `cluster_name` in the HCL configuration.  use the `config` parameter in the Vault Helm chart.

   </Note>

   Helm deploys the Vault pods and Vault Agent Injector pod in the default namespace.

1. Install the latest version of the Vault Helm chart with Integrated Storage.

   ```shell-session
   $ helm install vault hashicorp/vault --values helm-vault-raft-values.yml
   ```

   This creates three Vault server instances with an Integrated Storage (Raft) backend. 

   Helm installs the Vault pods and Vault Agent Injector pod in the default namespace.


## Step 4: Initialize and unseal primary Vault pod

Vault starts [uninitialized](/vault/docs/commands/operator/init) and in the [sealed](/vault/docs/concepts/seal#why) state. Prior to initialization the Integrated Storage backend is not prepared to receive data.

1. Initialize Vault with one key share and one key threshold.

   ```shell-session
   $ kubectl exec vault-0 -- vault operator init \
       -key-shares=1 \
       -key-threshold=1 \
       -format=json > cluster-keys.json
   ```

1. Display the unseal key found in `cluster-keys.json`.

   ```shell-session
   $ cat cluster-keys.json | jq -r ".unseal_keys_b64[]"
   ```

1. Create a variable named `VAULT_UNSEAL_KEY` to capture the Vault unseal key.

   ```shell-session
   $ VAULT_UNSEAL_KEY=$(cat cluster-keys.json | jq -r ".unseal_keys_b64[]")
   ```

1. Unseal Vault running on the `vault-0` pod.

   ```shell-session
   $ kubectl exec vault-0 -- vault operator unseal $VAULT_UNSEAL_KEY
   ```

## Step 5: Join the other Vaults to the Vault cluster

The Vault server running on the `vault-0` pod is a Vault HA cluster with a
single node. To display the list of nodes requires that you are logging in with
the root token.

1. Create a variable named `CLUSTER_ROOT_TOKEN` to capture the Vault unseal key.

   ```shell-session
   $ CLUSTER_ROOT_TOKEN=$(cat cluster-keys.json | jq -r ".root_token")
   ```

1. Login with the root token on the `vault-0` pod.

   ```shell-session
   $ kubectl exec vault-0 -- vault login $CLUSTER_ROOT_TOKEN
   ```

1. Join the Vault server on `vault-1` to the Vault cluster.

   ```shell-session
   $ kubectl exec vault-1 -- vault operator raft join http://vault-0.vault-internal:8200
   ```

   This Vault server joins the cluster sealed. To unseal the Vault server requires
   the same unseal key, `VAULT_UNSEAL_KEY`, provided to the first Vault server.

1. Unseal the Vault server on `vault-1` with the unseal key.

   ```shell-session
   $ kubectl exec vault-1 -- vault operator unseal $VAULT_UNSEAL_KEY
   ```

   The Vault server on `vault-1` is now a functional node within the Vault
   cluster.

1. Join the Vault server on `vault-2` to the Vault cluster.

   ```shell-session
   $ kubectl exec vault-2 -- vault operator raft join http://vault-0.vault-internal:8200
   ```

1. Unseal the Vault server on `vault-2` with the unseal key.

   ```shell-session
   $ kubectl exec vault-2 -- vault operator unseal $VAULT_UNSEAL_KEY
   ```

## Step 6: Set a secret in Vault

The web application expects Vault to store a username and password at the path `secret/webapp/config`. Creating this secret requires you to login with the root token, enable the key-value secret engine](/vault/docs/secrets/kv/kv-v2), and store a secret username and password at that defined path.

1. First, start an interactive shell session on the `vault-0` pod.

   ```shell-session
   $ kubectl exec --stdin=true --tty=true vault-0 -- /bin/sh
   / $
   ```

   This replaces the system prompt with a new prompt `/ $`.

1. Enable kv-v2 secrets at the path `secret`.

   ```shell-session
   $ vault secrets enable -path=secret kv-v2
   ```

1. Create a secret at path `secret/devwebapp/config` with a `username` and
`password`.

   ```shell-session
   $ vault kv put secret/devwebapp/config username='giraffe' password='salsa'
   ```

1. Verify that the secret is defined at the path `secret/data/devwebapp/config`.

   ```shell-session
   $ vault kv get secret/devwebapp/config
   ```

   <Note title="Learn more">

   For more information refer to the [Versioned Key/Value Secrets Engine](/vault/tutorials/secrets-management/versioned-kv) tutorial.

   </Note>

   You created the secret for the web application.

## Step 7: Configure Kubernetes authentication

The initial [root token](/vault/docs/concepts/tokens#root-tokens) is a privileged user that can perform any operation at any path. The web application only requires the ability to read secrets defined at a single path. This application should authenticate and Vault grants a token with limited access.

<Note title="Best practice">

We recommend that [root
tokens](/vault/docs/concepts/tokens#root-tokens) are
used only for initial setup of an authentication method and policies. Afterwards they should be revoked. This tutorial does not show you how to revoke the root token.

</Note>

Vault provides a [Kubernetes authentication](/vault/docs/auth/kubernetes) method that enables clients to authenticate with a Kubernetes Service Account Token.

1. Enable the Kubernetes authentication method.

   ```shell-session
   $ vault auth enable kubernetes
   Success! Enabled kubernetes auth method at: kubernetes/
   ```

   Vault accepts a service token from any client within the Kubernetes cluster. During authentication, Vault verifies that the service account token is valid by querying a token review Kubernetes endpoint.

1. Configure the Kubernetes authentication method to use the location of the Kubernetes API. It will automatically use the pod's own identity to authenticate with Kubernetes when querying the token review API.

   ```shell-session
   $ vault write auth/kubernetes/config \
      kubernetes_host="https://$KUBERNETES_PORT_443_TCP_ADDR:443"
   ```

1. Write out the policy named `devwebapp` that enables the `read` capability for secrets at path `secret/data/devwebapp/config`.

   ```shell-session
   $ vault policy write devwebapp - <<EOF
   path "secret/data/devwebapp/config" {
   capabilities = ["read"]
   }
   EOF
   ```

1. Create a Kubernetes authentication role named `devweb-app`.

   ```shell-session
   $ vault write auth/kubernetes/role/devweb-app \
         bound_service_account_names=internal-app \
         bound_service_account_namespaces=default \
         policies=devwebapp \
         ttl=24h
   ```

   The role connects a Kubernetes service account, `internal-app` (created in the next step), and namespace, `default`, with the Vault policy, `devwebapp`. The tokens returned after authentication are valid for 24 hours.

1. Lastly, exit the `vault-0` pod.

   ```shell-session
   $ exit
   ```

## Step 8: Deploy web application

The web application pod requires the creation of the `internal-app` Kubernetes service account specified in the Vault Kubernetes authentication role created in the [Configure Kubernetes authentication](#configure-kubernetes-authentication)
step.

1. Create a Kubernetes service account named `internal-app`.

   ```shell-session
   $ kubectl create sa internal-app
   ```

1. Define a pod named `devwebapp` with the web application.

   ```shell-session
   $ cat > devwebapp.yaml <<EOF
   ---
   apiVersion: v1
   kind: Pod
   metadata:
      name: devwebapp
      labels:
         app: devwebapp
      annotations:
         vault.hashicorp.com/agent-inject: "true"
         vault.hashicorp.com/role: "devweb-app"
         vault.hashicorp.com/agent-inject-secret-credentials.txt: "secret/data/devwebapp/config"
   spec:
   serviceAccountName: internal-app
   containers:
      - name: devwebapp
         image: caddy
   EOF
   ```

   This definition creates a pod with the specified container running with the `internal-app` Kubernetes service account. The container within the pod is unaware of the Vault cluster. The Vault Injector service reads the [annotations](/vault/docs/platform/k8s/injector#annotations) to find the secret path, stored within Vault at `secret/data/devwebapp/config` and the file location, `/vault/secrets/secret-credentials.txt`, to mount that secret with the pod.

   <Note title="Learn more">

   For more information about annotations refer to the [Injecting Secrets into Kubernetes Pods via Vault Agent
   Injector](/vault/tutorials/kubernetes/kubernetes-sidecar) tutorial.

   </Note>

1. Create the `devwebapp` pod.

   ```shell-session
   $ kubectl apply --filename devwebapp.yaml
   ```

1. Wait until the `devwebapp` pod reports that is running and ready (`2/2`).

1. Display the secrets written to the file `/vault/secrets/secret-credentials.txt`
on the `devwebapp` pod.

   ```shell-session
   $ kubectl exec --stdin=true --tty=true devwebapp -c devwebapp -- cat /vault/secrets/credentials.txt
   data: map[password:salsa username:giraffe]
   metadata: map[created_time:2020-12-11T19:14:05.170436863Z deletion_time: destroyed:false version:1]
   ```

   The result displays the unformatted secret data present on the container.

<Tip title="Format data">

Apply a [template](/vault/tutorials/kubernetes/kubernetes-sidecar#apply-a-template-to-the-injected-secrets) to this structure this data to meet the needs of the application.

</Tip>

## Step 9: Clean up

Destroy the cluster.

```shell-session
$ gcloud container clusters delete learn-vault
```   
