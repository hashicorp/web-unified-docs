---
layout: docs
page_title: Deploy Vault on Google Kubernetes Engine (GKE)
description: >-
  Guide to deploying and setting up Vault on Google Kubernetes Engine (GKE).
---

# Deploy Vault on Google Kubernetes Engine (GKE)

Google Kubernetes Engine (GKE) can run Vault in its secured and managed
Kubernetes service in standard or autopilot mode. Standard mode gives you the flexibility to configure the cluster's underlying infrastructure while autopilot mode gives you an optimized cluster with a hands-off experience.



## Before you start

- You should be familiar with Kubernetes concepts list pods, service accounts,
  and manifests.
- You should be familiar with Google Cloud projects and Google Kubernetes Engine
  (GKE).
- You must have a [Google Cloud account](https://console.cloud.google.com) with
  a project initialized and  Google container service (`container.googleapis.com`)
  enabled.
- You must have the [Google Cloud CLI](https://cloud.google.com/sdk/docs/quickstart)
  installed.
- You must have the
  [Kubernetes CLI](https://kubernetes.io/docs/tasks/tools/install-kubectl/)
  installed.
- You must have the [Helm CLI](https://helm.sh/docs/helm/) installed.
- You must have [jq](https://jqlang.org/) installed.



## Step 1: Add the Hashicorp repo to Helm

You must have the Vault Helm chart to deploy Vault. You can add the Hashicorp
repository (`helm.releases.hashicorp.com`) with the `helm repo add` command:

```shell-session
$ helm repo add hashicorp https://helm.releases.hashicorp.com
```



## Step 2: Start a GKE cluster

1. Use the `TBD` command to log into your Google Cloud account with your preferred
   project and region selected:

   ```shell-session
   $ command TBD
   ```

1. Create a high-availability Vault cluster in autopilot mode named `learn-vault`
   with a minimum of three nodes:

   ```shell-session
   $ gcloud container clusters create-auto learn-vault
   ```   
   
   While you can also create the nodes manually, autopilot manages the
   underlying infrastructure on your behalf so so you can start with a smaller
   set of nodes but provisions more as needed.

Once Google Cloud creates, deploys, and confirms the health of the cluster it
modifies your `kubectl` configuration to perform any commands you issue against
the cluster.



## Step 3: Install Vault using helm

The Vault Helm chart contains all the necessary components to run Vault in
several different modes.

<Tip title="Set cluster name for Prometheus monitoring">

   If you use Prometheus for monitoring and alerting, we recommend setting the
   `cluster_name` in your HCL configuration using the `config` parameter in the
   Vault Helm chart.

</Tip>

1. Create a file named `helm-vault-raft-values.yml` with a basic deployment
   configuration that deploys the Vault pods and Vault Agent Injector pod in the
   default namespace:

   ```shell-session
   $ cat > helm-vault-raft-values.yml <<EOF
   server:
      affinity: ""
      ha:
         enabled: true
         raft:
            enabled: true
            setNodeId: true
            config: |
               cluster_name = "vault-integrated-storage"
               storage "raft" {
                  path    = "/vault/data/"
               }

               listener "tcp" {
                  address = "[::]:8200"
                  cluster_address = "[::]:8201"
                  tls_disable = "true"
               }
               service_registration "kubernetes" {}
   EOF
   ```

1. Use your deployment configuration with `helm install` to install the latest
   version of the Vault Helm chart and create three Vault server instances with
   an integrated storage backend:

   ```shell-session
   $ helm install vault hashicorp/vault --values helm-vault-raft-values.yml
   ```


## Step 4: Initialize and unseal the primary Vault pod

Vault starts [sealed](/vault/docs/concepts/seal#why) and 
[uninitialized](/vault/docs/commands/operator/init). Before Vault can receive
data, you need to initialization the integrated storage backend and use the
provided keys to unseal Vault.

1. Use the Kubernetes CLI to initialize Vault with one key share and one key
   threshold:

   ```shell-session
   $ kubectl exec vault-0 -- vault operator init \
       -key-shares=1 \
       -key-threshold=1 \
       -format=json > cluster-keys.json
   ```

1. Display the unseal key found in `cluster-keys.json`:

   ```shell-session
   $ cat cluster-keys.json | jq -r ".unseal_keys_b64[]"
   ```

1. Create a variable named `VAULT_UNSEAL_KEY` to capture the Vault unseal key:

   ```shell-session
   $ VAULT_UNSEAL_KEY=$(cat cluster-keys.json | jq -r ".unseal_keys_b64[]")
   ```

1. Unseal Vault running on the `vault-0` pod:

   ```shell-session
   $ kubectl exec vault-0 -- vault operator unseal $VAULT_UNSEAL_KEY
   ```


## Step 5: Join additional nodes to the Vault cluster

The Vault server running on the `vault-0` pod is a high-availability cluster,
currently running with a single node. To create a true high-availability
cluster, you need to additional nodes.

1. Create a variable named `CLUSTER_ROOT_TOKEN` to capture the Vault unseal key:

   ```shell-session
   $ CLUSTER_ROOT_TOKEN=$(cat cluster-keys.json | jq -r ".root_token")
   ```

1. Log in with the root token on `vault-0` so you can access the list of
   available nodes:

   ```shell-session
   $ kubectl exec vault-0 -- vault login $CLUSTER_ROOT_TOKEN
   ```

1. List the available nodes:

   ```shell-session
   $ TBD
   ```

1. Use the Kubernetes CLI to join additional nodes to the Vault cluster. For
   example, to add the Vault server on `vault-1`:

   ```shell-session
   $ kubectl exec vault-1 -- vault operator raft join http://vault-0.vault-internal:8200
   ```

1. New nodes join the cluster sealed. Use the `VAULT_UNSEAL_KEY` key to unseal
   the new Vault server. For example, to unseal the server on `vault-1`:

   ```shell-session
   $ kubectl exec vault-1 -- vault operator unseal $VAULT_UNSEAL_KEY
   ```

1. Repeat the join and unseal process for each additional server in the cluster.


<Warning title="Revoke root tokens after setup">

   [Root tokens](/vault/docs/concepts/tokens#root-tokens) let users perform any
   operation on any path. We strongly recommend only using privileged tokens for
   the initial setup of a cluster, including an alternative authentication method
   and policy. Once you verify the alternative authentication method works, we
   recommend revoking the root token.

</Warning>


## Step 6: Test your cluster deployment 

You can test that the deployment works correctly by enabling the
[`kv` plugin](/vault/docs/secrets/kv/kv-v2) and setting a test secret.

1. Start an interactive shell session on the `vault-0` pod:

   ```shell-session
   $ kubectl exec --stdin=true --tty=true vault-0 -- /bin/sh
   / $
   ```

1. Use the Vault CLI on `vault-0` to enable the `kv` plugin at the path `creds`:

   ```shell-session
   $ vault secrets enable -path=creds kv-v2
   ```

1. Use the Vault CLI on `vault-0` to save a username and password at the path
   `creds/devapp`:

   ```shell-session
   $ vault kv put creds/devapp username='giraffe' password='salsa'
   ```

1. Use the Vault CLI on `vault-0` to verify the secret saved correctly at
   `creds/devapp`:

   ```shell-session
   $ vault kv get creds/devapp
   ```


## Step 7: Create a Kubernetes service account for clients

Create a Kubernetes service account for clients so you can link the service
account to a Vault policy for authentication.

1. Create a Kubernetes service account with a unique name. For example:

   ```shell-session
   $ kubectl create sa internal-app
   ```

1. Define a pod for the client application. For example, to create a test
   application named `devwebapp` running with the `internal-app` Kubernetes
   service account:

   ```shell-session
   $ cat > devwebapp.yaml <<EOF
   ---
   apiVersion: v1
   kind: Pod
   metadata:
      name: devwebapp
      labels:
         app: devwebapp
      annotations:
         vault.hashicorp.com/agent-inject: "true"
         vault.hashicorp.com/role: "devweb-app"
         vault.hashicorp.com/agent-inject-secret-credentials.txt: "secret/data/devwebapp/config"
   spec:
   serviceAccountName: internal-app
   containers:
      - name: devwebapp
         image: caddy
   EOF
   ```

1. Create the client application pod. For example, to create the `devwebapp`
   pod:

   ```shell-session
   $ kubectl apply --filename devwebapp.yaml
   ```

1. Wait until your client pod reports that it is running and ready (`2/2`).


## Step 8: Configure Kubernetes authentication

Vault provides a [Kubernetes authentication](/vault/docs/auth/kubernetes) method
that lets clients authenticate with Kubernetes ServiceAccount tokens. With
Kubernetes authentication, Vault accepts service tokens from clients within
the Kubernetes cluster and verifies the service account token by querying a
token review Kubernetes endpoint.

To enable Kubernetes authentication:

1. If you closed the previous interactive shell session on the `vault-0` pod,
   start a new one:

   ```shell-session
   $ kubectl exec --stdin=true --tty=true vault-0 -- /bin/sh
   / $
   ```

1. Use the Vault CLI on `vault-0` to enable the Kubernetes authentication
   plugin on the default path:

   ```shell-session
   $ vault auth enable kubernetes
   Success! Enabled kubernetes auth method at: kubernetes/
   ```

1. Configure the `kubernetes/` plugin to use the Kubernetes API to validate
   ServiceAccount tokens using the identity of the pod:

   ```shell-session
   $ vault write auth/kubernetes/config \
      kubernetes_host="https://$KUBERNETES_PORT_443_TCP_ADDR:443"
   ```

1. Use the Vault CLI to write out a policy that lets clients read any required
   secrets. For example, use `vault policy write` to create a policy called
   `devwebapp` that lets clients read credentials from the `kv` path
   `creds/devapp`:

   ```shell-session
   $ vault policy write devwebapp - <<EOF
   path "creds/data/devapp" {
   capabilities = ["read"]
   }
   EOF
   ```

1. Create a cooresponding Kubernetes authentication role that uses the new
   policy. For example, to create an authentication role called `devweb-app`
   that uses the `devwebapp` policy:

   ```shell-session
   $ vault write auth/kubernetes/role/devweb-app \
         bound_service_account_names=internal-app \
         bound_service_account_namespaces=default \
         policies=devwebapp \
         ttl=24h
   ```

The authentication role connects the Kubernetes service account named in
`bound_service_account_names` to the Vault policy named in `policies`.



Step 9: Verify communication between Vault and the client

The application container within the client pod is unaware of the Vault cluster.
The Vault Injector service reads the
[annotations](/vault/docs/platform/k8s/injector#annotations) to find the secret
path, stored within Vault at `secret/data/devwebapp/config` and the file location,
`/vault/secrets/secret-credentials.txt`, to mount that secret with the pod.

You can verify that your authentication policy works by reading the secrets
written to the file `/vault/secrets/secret-credentials.txt` on the `devwebapp`
pod which should match the secret data from secret paths granted by the Vault
policy. For example:

```shell-session
$ kubectl exec    \
   --stdin=true   \
   --tty=true     \
   devwebapp      \
   -c devwebapp   \
   -- cat /vault/secrets/credentials.txt

data: map[password:salsa username:giraffe]
metadata: map[created_time:2020-12-11T19:14:05.170436863Z deletion_time: destroyed:false version:1]
```

<Tip title="Format data with templates">

   Apply a
   [template](/vault/tutorials/kubernetes/kubernetes-sidecar#apply-a-template-to-the-injected-secrets)
   to the secret file to ensure the data meets the needs of your application.

</Tip>



## Additional resources

<Tabs>

<Tab heading="Guides" group="guides">

- [Key/Vault plugin guides and cookbook](/vault/docs/secrets/kv/kv-v2)

</Tab>

<Tab heading="Tutorials" group="tutorial">

- [Using the versioned Key/Value secrets engine](/vault/tutorials/secrets-management/versioned-kv).
- [Use annotations to inject Secrets into Kubernetes Pods with Vault Agent Injector](/vault/tutorials/kubernetes/kubernetes-sidecar) tutorial.

</Tab>

<Tab heading="References" group="references">


</Tab>

</Tabs>
