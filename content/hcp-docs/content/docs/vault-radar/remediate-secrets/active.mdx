---
page_title: Remediate leaked secrets
description: >-
  Remediate secrets found in your code.
---

# Remediate leaked secrets

HCP Vault Radar can scan for secrets leaked in your code.

## Create an incident

Leaked secrets can lead to unauthorized access to your services. To prevent
malicious activity, HashiCorp recommends users to rotate and store the secret in Vault.

- Follow your organization’s guidelines for emergency rotation of a secret.
- Determine if your company already uses HashiCorp Vault.

## Store secrets in Vault KVv2 secret engine

This example uses the KVv2 secrets engine and AppRole auth method. If your application is
already configured to access secrets in Vault, use existing secrets engines and
auth methods.

<Note>

Before getting started install the [Vault CLI](/vault/docs/commands#vault-commands-cli)

</Note>

1. Set the following environment variables in your local environment:

   ```plaintext
   VAULT_TOKEN
   VAULT_ADDR
   VAULT_NAMESPACE
   ```

   <Note>

   Make sure you know your Vault namespace and plugin mount path.

   </Note>

1. Add the secret to the Vault KV version 2 secrets engine.

   ```shell-session
   $ vault kv put -mount=mount-path my-secret my-secret-value=secret-value
   ```

1. Read the secret.

   ```shell-session
   $ vault kv get -mount=mount-path my-secret
   ```

1. Create a policy to allow access to the KVv2 secret engine.

   ```shell-session
   $ vault policy write my-policy -<<EOF
      path "my-secret" {
 		   capabilities = [ "read" ]
      }
   EOF
   ```

1. Enable the `AppRole` authentication method.

   ```shell-session
   $ vault auth enable approle
   ```

   <Note>

   Refer to [this documentation](/vault/docs/auth) to learn more about other authentication methods that Vault supports

   </Note>

1. Create a role and attach the policy.

   ```shell-session
   $  vault write auth/approle/role/my-role \
        token_policies=my-policy
   ```

## Remove the secret from code

Now that the secret is available from Vault, remove the hardcoded secret
from the source code. This example uses an environment variable to store the
secret from Vault.

1. Populate the environment variable `MY_SECRET` with the secret and start your local server.

   ```shell-session
   $  export MY_SECRET=$(vault kv get -mount=month-path {SECRET} my-secret-value)
   ```

1. Start the application.

   ```shell-session
   $ run-my-app
   ```

1. Remove the secret from source and add a reference to the secret stored at the environment variable MY_SECRET.

   <Tabs>
   <Tab heading="C++">

   `mySecret = getenv(“MY_SECRET”)`

   </Tab>
   <Tab heading="Python">

   `mySecret = os.getenv("MY_SECRET")`

   </Tab>
   <Tab heading="Spring">

   `System.getProperty("MY_SECRET")`

   </Tab>
   </Tabs>

<Note>

If you are not using an environment variable to read the secret, here are some other ways to store or retrieve secrets from Vault:

- Create secrets with the [Vault secrets operator](/vault/tutorials/kubernetes/vault-secrets-operator) for Kubernetes.
- Use Vault Enterprise [secret sync](/vault/tutorials/enterprise/secrets-sync) for services like Vercel or Heroku.
- Read and reload secrets in [Spring](/vault/tutorials/app-integration/spring-reload-secrets).
- If you do not use environment variables, refer to the [Vault API documentation](/vault/api-docs/secret/gcp#generate-secret-iam-service-account-creds-oauth2-access-token)

</Note>

## Revoke the secret

Revoke the secret to complete the remediation process.

- Validate the environment variable value is from Vault.
- Deploy and test the application.
- Work with the service owner to rotate the secret stored in the Vault.
- Update the secret value in Vault

   ```shell-session
   $ vault kv put -mount=mount-path my-secret my-secret-value=new-value
   ```
