The recommended practice is to deploy the Agent using Kubernetes. A sample
manifest is available alongside [the
releases](https://releases.hashicorp.com/vault-radar/). 

**Example deployment:**

<CodeBlockConfig>

```yaml
---
apiVersion: v1
kind: Namespace
metadata:
  name: vault-radar
  labels:
    app: vault-radar-agent

---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: vault-radar-agent
  namespace: vault-radar
  labels:
    app: vault-radar-agent

---
# Note: This cluster role binding is only required if you are using the Kubernetes auth method for Vault indexing feature.
# It is needed for Vault to be able to review the Kubernetes service account token and authenticate the Agent.
# See https://developer.hashicorp.com/vault/docs/auth/kubernetes#configuring-kubernetes

# apiVersion: rbac.authorization.k8s.io/v1
# kind: ClusterRoleBinding
# metadata:
#   name: vault-radar-agent
# roleRef:
#   apiGroup: rbac.authorization.k8s.io
#   kind: ClusterRole
#   name: system:auth-delegator
# subjects:
#   - kind: ServiceAccount
#     name: vault-radar-agent
#     namespace: vault-radar

---
apiVersion: v1
kind: Secret
metadata:
  name: vault-radar-secrets
  namespace: vault-radar
  labels:
    app: vault-radar-agent
type: Opaque
data:
  HCP_CLIENT_SECRET: <Base64 Encoded HCP_CLIENT_SECRET>
  VAULT_RADAR_GIT_TOKEN: <Base64 Encoded VAULT_RADAR_GIT_TOKEN>
  
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: vault-radar-agent
  namespace: vault-radar
  labels:
    app: vault-radar-agent
spec:
  replicas: 2
  selector:
    matchLabels:
      app: vault-radar-agent
  template:
    metadata:
      labels:
        app: vault-radar-agent
    spec:
      serviceAccountName: vault-radar-agent
      automountServiceAccountToken: true
      containers:
        - name: vault-radar-agent
          image: docker.io/hashicorp/vault-radar:latest
          command: ["vault-radar"]
          args: ["agent", "exec"]
          imagePullPolicy: Always
          tty: true
          resources:
            limits:
              cpu: 1000m
              memory: 1024Mi
            requests:
              cpu: 100m
              memory: 512Mi
          env:
            - name: HCP_PROJECT_ID
              value: <HCP_PROJECT_ID>
            - name: HCP_RADAR_AGENT_POOL_ID
              value: <HCP_RADAR_AGENT_POOL_ID>
            - name: HCP_CLIENT_ID
              value: <HCP_CLIENT_ID>
            - name: HCP_CLIENT_SECRET
              valueFrom:
                secretKeyRef:
                  name: vault-radar-secrets
                  key: HCP_CLIENT_SECRET
            - name: VAULT_RADAR_GIT_TOKEN
              valueFrom:
                secretKeyRef:
                  name: vault-radar-secrets
                  key: VAULT_RADAR_GIT_TOKEN
```

</CodeBlockConfig>

The example manifest is using Kubernetes Secrets for the sensitive credentials.
This requires base64 encoding the values, and loading the secrets as
environment variables on the pod(s). There are different ways you can configure the
deployment as long as you set the environment variables `vault-radar` on the pod(s).

If you are using command line utilities to base64 encode the values,
make sure to exclude the trailing newline character at the end of the input.
For example, you can use the following command:

```shell-session
$ echo -n "<some value>" | base64
```

When deployed, each pod will output logs to `stderr`. You can tail the logs as
you would any other Kubernetes pod using the `kubectl` command:

```shell-session
$ kubectl logs <pod name> -f
```