---
page_title: 'Import: collection/maps'
sidebar_current: docs-imports-collection-maps
description: The collection/maps import provides useful helpers for working with maps.
layout: docs
---

# Import: collection/maps

The `collection/maps` import provides helpers for working with [maps](/sentinel/language/maps).

## get

**_get(object, path[, default])_**

Get the value from the provided object using the [path](#paths).
When the path is invalid or the object doesn't contain a value at the path, then the default is returned. The default return value is undefined.

### Arguments

| Name      | Description |
|-----------|-------------|
| object    | the map to perform the get against. |
| path      | a [path](#paths) to a key within object to retreive the value |
| default   | an optional value that will return if the path does not exist or returns undefined |

### Examples

Get a value from a simple object:

```sentinel playground
import "collection/maps" as maps

object = {"foo": "bar"}
item = maps.get(object, "foo")
main = item is "bar"
```

Get a nested value from a complex object:

```sentinel playground
import "collection/maps" as maps

object = {"foo": [{"bar": {"baz": 4}}]}
item = maps.get(object, "foo.0.bar.baz")
main = item is 4
```

Get a list of values using [splat](#splat):

```sentinel playground
import "collection/maps" as maps

object = {"foo": [{"bar": 4}, {"bar": 8}, {"bar": 45}]}
item = maps.get(object, "foo.*.bar")
main = item is [4, 8, 45]
```

Get an invalid path, providing a default:

```sentinel playground
import "collection/maps" as maps

object = {}
item = maps.get(object, "foo", "bar")
main = item is "bar"
```

Get an invalid path, not providing a default:

```sentinel playground
import "collection/maps" as maps

object = {}
item = maps.get(object, "foo")
main = item is not defined
```

## has

**_has(object, path)_**

Return a boolean value if the object has the path within its structure.

### Arguments

| Name      | Description |
|-----------|-------------|
| object    | the map to perform the has against. |
| path      | a [path](#paths) to a key within object to determine if it exists |

### Examples

An object has a valid key:

```sentinel playground
import "collection/maps" as maps

object = {"foo": "bar"}
main = maps.has(object, "foo")
```

An object does not have a valid key:

```sentinel playground
import "collection/maps" as maps

object = {}
main = maps.has(object, "foo") is false
```

## omit

**_omit(object, paths)_**

Return a map, removing each path from the paths provided from the source object.
The original structure of the map is maintained, as seen in the below examples.

### Arguments

| Name      | Description |
|-----------|-------------|
| object    | the map to perform the omit against. |
| paths     | a list of [paths](#paths) to be removed from the source object |

### Examples

Omitting a single value:

```sentinel playground
import "collection/maps" as maps

object = {"foo": "bar"}
main = maps.omit(object, ["foo"]) is {}
```

Omitting multiple values:

```sentinel playground
import "collection/maps" as maps

object = {"foo": "bar", "baz": "qux", "nit": "nat"}
main = maps.omit(object, ["foo", "baz"]) is {"nit": "nat"}
```

Omitting deep values:

```sentinel playground
import "collection/maps" as maps

object = {
  "foo": "bar",
  "baz": [
    { "qux": 4 },
    { "qux": 10 }
  ],
  "nit": {
    "nat": "pak"
  }
}
main = maps.omit(object, ["baz.1.qux", "nit.nat"]) is {"foo": "bar", "baz": [{"qux": 4}]}
```

## pick

**_pick(object, paths)_**

Return a map consisting of each value found in object from the paths provided.
The original structure of the map is maintained, as seen in the below examples.

### Arguments

| Name      | Description |
|-----------|-------------|
| object    | the map to perform the pick against. |
| paths     | a list of [paths](#paths), each used to select a value from the object. |

### Examples

Picking a single value:

```sentinel playground
import "collection/maps" as maps

object = {"foo": "bar"}
main = maps.pick(object, ["foo"]) is {"foo": "bar"}
```

Picking multiple values:

```sentinel playground
import "collection/maps" as maps

object = {"foo": "bar", "baz": "qux", "nit": "nat"}
main = maps.pick(object, ["foo", "baz"]) is {"foo": "bar", "baz": "qux"}
```

Picking deep values:

```sentinel playground
import "collection/maps" as maps

object = {
  "foo": "bar",
  "baz": [
    { "qux": 4 },
    { "qux": 10 }
  ],
  "nit": {
    "nat": "pak"
  }
}
main = maps.pick(object, ["baz.1.qux", "nit.nat"]) is {"baz": [{"qux": 10}], "nit": {"nat": "pak"}}
```

## set

**_set(object, path, value)_**

Return a new map, assigning the provided value to the provided path. It will
not modify the provided map in place.

### Arguments

| Name      | Description |
|-----------|-------------|
| object    | the map to perform the set against. |
| path      | the [path](#paths) to assign value |
| value     | the value to be assigned |

### Examples

Set a value on a simple path:

```sentinel playground
import "collection/maps" as maps

object = {"foo": "bar"}
object = maps.set(object, "foo", "qux")
main = object is {"foo": "qux"}
```

Set a value on a deep path:

```sentinel playground
import "collection/maps" as maps

object = {}
object = maps.set(object, "foo.bar.baz", 10)
main = object is {"foo": { "bar": { "baz": 10 } } }
```

Set a value on an index in a list:

```sentinel playground
import "collection/maps" as maps

object = {"foo": [ 2, 5 ] }
object = maps.set(object, "foo.0", 10)
main = object is {"foo": [ 10, 5 ] }
```

Set a value on every key within a list key:

```sentinel playground
import "collection/maps" as maps

object = {"foo": [ { "bar": true }, { "bar": false } ] }
object = maps.set(object, "foo.*.bar", true)
main = object is {"foo": [ { "bar": true }, { "bar": true } ] }
```

## unset

**_unset(object, path)_**

Return a new map, removing the provided path from the source object. It will
not modify the provided map in place.

### Arguments

| Name      | Description |
|-----------|-------------|
| object    | the map to perform the unset against. |
| path      | the [path](#paths) to remove |

### Examples

Unset on a simple path:

```sentinel playground
import "collection/maps" as maps

object = {"foo": "bar"}
object = maps.unset(object, "foo")
main = object is {}
```

Unset on a deep path:

```sentinel playground
import "collection/maps" as maps

object = {"foo": { "bar": { "baz": 10, "qux": 15 } } }
object = maps.unset(object, "foo.bar.baz")
main = object is {"foo": { "bar": { "qux": 15 } } }
```

Unset an index in a list:

```sentinel playground
import "collection/maps" as maps

object = {"foo": [ 2, 5 ] }
object = maps.unset(object, "foo.0")
main = object is {"foo": [ 5 ] }
```

Unset a list:

```sentinel playground
import "collection/maps" as maps

object = {"foo": [ { "bar": true }, { "bar": false } ] }
object = maps.unset(object, "foo.*", true)
main = object is {"foo": [] }
```

## Paths

Map helpers often receive a **path** argument that allows for looking up a nested
key. Generally speaking, a path is a series of keys separated by `.`, however there
are some additional capabilites that need to be explained.

### Lists

When traversing a nested map that contains a list, a specific index can be retrieved
by providing the index as the part of the path.

In the following code sample, the path will first enter the key `"foo"` within the
map, followed by entering the first index of the list.

```sentinel
path = "foo.0"
object = {"foo": [1]}
```

### Splat

To provide advanced capabilities when using paths, you can also use the splat (`*`)
operator to iterate through **all** elements in a list, with all parts of the path
following the splat occuring on each entry.

In the following code sample, the path will first enter the key `"foo"` within the map.
It will then enter each item in the list, entering the `"bar"` key for each nested object.

```sentinel
path = "foo.*.bar"
object = {"foo": [{"bar": 1}, {"bar": 2}]}
```
